{"version":3,"file":"sales-oNOFhEgV.js","sources":["../../src/lib/supabaseClient.ts","../../src/lib/apiService.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\nimport { Database } from './database.types';\n\n// Default Supabase config (Das Board Master)\nconst supabaseUrl = import.meta.env.VITE_SUPABASE_URL || '';\nconst supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY || '';\n\n// Dealership1 Supabase config\nconst dealership1Url = import.meta.env.VITE_DEALERSHIP1_SUPABASE_URL || '';\nconst dealership1AnonKey = import.meta.env.VITE_DEALERSHIP1_SUPABASE_ANON_KEY || '';\n\n// Validate main configuration\nif (!supabaseUrl || !supabaseAnonKey) {\n  throw new Error('Missing Supabase configuration. Please check your environment variables.');\n}\n\n// Create singleton instance with proper configuration\nlet supabaseInstance: ReturnType<typeof createClient<Database>> | null = null;\n\nconst createSupabaseClient = () => {\n  if (supabaseInstance) {\n    return supabaseInstance;\n  }\n\n  console.log('Initializing Supabase client:', {\n    url: supabaseUrl,\n    keyLength: supabaseAnonKey.length,\n    timestamp: new Date().toISOString(),\n  });\n\n  supabaseInstance = createClient<Database>(supabaseUrl, supabaseAnonKey, {\n    auth: {\n      persistSession: true, // Enable session persistence\n      autoRefreshToken: true, // Enable auto-refresh\n      detectSessionInUrl: true, // Enable URL session detection for redirects\n      storage: window.localStorage, // Use localStorage for session storage\n    },\n    global: {\n      headers: {\n        'X-Client-Info': 'dasboard-app',\n      },\n    },\n  });\n\n  return supabaseInstance;\n};\n\n// Export the main client - this replaces the old direct createClient call\nexport const supabase = createSupabaseClient();\n\n// Client instances cache\nconst clientInstances = new Map<string, ReturnType<typeof createClient<Database>>>();\n\n// Get Supabase client for a specific dealership\nexport const getDealershipSupabase = (dealershipId?: string | number) => {\n  // If no dealershipId or it's 'master', return the master project\n  if (!dealershipId || dealershipId === 'master') {\n    return supabase;\n  }\n\n  // For now, we only have Dealership1 as a separate project\n  if (dealershipId === 1 || dealershipId === '1' || dealershipId === 'dealership1') {\n    if (!dealership1Url || !dealership1AnonKey) {\n      console.warn('Dealership1 Supabase configuration missing, falling back to master project');\n      return supabase;\n    }\n\n    // Check if we already have an instance\n    const cacheKey = `dealership-${dealershipId}`;\n    if (clientInstances.has(cacheKey)) {\n      return clientInstances.get(cacheKey)!;\n    }\n\n    // Create a new instance\n    console.log(`Creating new Supabase client for dealership ${dealershipId}`);\n    const instance = createClient<Database>(dealership1Url, dealership1AnonKey, {\n      auth: {\n        persistSession: true,\n        storageKey: `dealership-${dealershipId}-auth`,\n        storage: window.localStorage,\n        detectSessionInUrl: true,\n        autoRefreshToken: true,\n      },\n    });\n\n    // Cache the instance\n    clientInstances.set(cacheKey, instance);\n    return instance;\n  }\n\n  // Default to master project if dealership ID doesn't match\n  console.warn(`No specific Supabase project for dealership ${dealershipId}, using master project`);\n  return supabase;\n};\n\n// Get the default Supabase client (Master project)\nexport const getSupabase = () => {\n  return supabase;\n};\n\n// Helper function to check if a session exists\nexport const hasValidSession = async () => {\n  try {\n    const {\n      data: { session },\n      error,\n    } = await supabase.auth.getSession();\n    if (error) {\n      console.error('Error checking session:', error);\n      return false;\n    }\n    return !!session;\n  } catch (error) {\n    console.error('Unexpected error checking session:', error);\n    return false;\n  }\n};\n\n// Get current session with error handling\nexport const getUserSession = async () => {\n  try {\n    const { data, error } = await supabase.auth.getSession();\n    if (error) {\n      console.error('Error getting session:', error);\n      throw error;\n    }\n    return { data, error: null };\n  } catch (error) {\n    console.error('Error in getUserSession:', error);\n    return { data: { session: null }, error };\n  }\n};\n\n// Cache for user roles to prevent excessive database queries\nconst userRoleCache = new Map<string, string>();\nlet pendingRequests = new Set<string>();\n\n// Get current user with role\nexport const getCurrentUser = async () => {\n  try {\n    const {\n      data: { user },\n      error: userError,\n    } = await supabase.auth.getUser();\n\n    if (userError) {\n      console.error('Error getting user:', userError);\n      return null;\n    }\n\n    if (!user) {\n      return null;\n    }\n\n    // Check cache first to avoid unnecessary database calls\n    if (userRoleCache.has(user.id)) {\n      const cachedRole = userRoleCache.get(user.id);\n      console.log('Using cached role for user:', { userId: user.id, role: cachedRole });\n      return {\n        ...user,\n        role: cachedRole,\n      };\n    }\n\n    // Guard against concurrent/repeated calls for the same user ID\n    const requestKey = `role-${user.id}`;\n    if (pendingRequests.has(requestKey)) {\n      console.warn('Avoiding duplicate role request for user:', user.id);\n      return {\n        ...user,\n        role: null, // Return null role, will be filled on next attempt after cache is populated\n      };\n    }\n\n    // Mark this request as in progress\n    pendingRequests.add(requestKey);\n\n    try {\n      // Get user's role from profiles table\n      const { data: profile, error: profileError } = await supabase\n        .from('profiles')\n        .select('role')\n        .eq('id', user.id)\n        .single();\n\n      if (profileError) {\n        console.error('Error fetching user role:', profileError);\n        // Try fallback to roles through users table\n        const { data: userData, error: userDataError } = await supabase\n          .from('users')\n          .select('role_id')\n          .eq('id', user.id)\n          .single();\n\n        if (!userDataError && userData?.role_id) {\n          // Get role name from role_id\n          const { data: roleData } = await supabase\n            .from('roles')\n            .select('name')\n            .eq('id', userData.role_id)\n            .single();\n\n          if (roleData?.name) {\n            // Cache the role\n            userRoleCache.set(user.id, roleData.name);\n            return {\n              ...user,\n              role: roleData.name,\n            };\n          }\n        }\n\n        // If no role found in either table, use default\n        userRoleCache.set(user.id, 'viewer');\n        return {\n          ...user,\n          role: 'viewer', // Default fallback role\n        };\n      }\n\n      // Cache the role\n      userRoleCache.set(user.id, profile.role);\n\n      return {\n        ...user,\n        role: profile.role,\n      };\n    } finally {\n      // Clean up pending request marker\n      pendingRequests.delete(requestKey);\n    }\n  } catch (error) {\n    console.error('Error in getCurrentUser:', error);\n    return null;\n  }\n};\n\n// Get current user's dealership ID\nexport const getUserDealershipId = async () => {\n  try {\n    const user = await getCurrentUser();\n    if (!user) return null;\n\n    // Try to get from users table first (newer schema)\n    const { data: userData, error: userError } = await supabase\n      .from('users')\n      .select('dealership_id')\n      .eq('id', user.id)\n      .single();\n\n    if (!userError && userData?.dealership_id) {\n      return userData.dealership_id;\n    }\n\n    // Fall back to profiles table (older schema)\n    const { data: profile, error: profileError } = await supabase\n      .from('profiles')\n      .select('dealership_id')\n      .eq('id', user.id)\n      .single();\n\n    if (!profileError && profile?.dealership_id) {\n      return profile.dealership_id;\n    }\n\n    console.warn('No dealership ID found for user:', user.id);\n    return null;\n  } catch (error) {\n    console.error('Error getting user dealership ID:', error);\n    return null;\n  }\n};\n\n// Export types\nexport type { Database } from './database.types';\n\nexport type DealType = 'Cash' | 'Finance' | 'Lease';\nexport type VehicleType = 'N' | 'U' | 'D';\nexport type DealStatus = 'Pending' | 'Funded' | 'Unwound';\n\n// Regular expression to check if an email is a test email\nexport const isTestEmail = (email: string): boolean => {\n  return /(@exampletest\\.com|@example\\.com|test.*@)/.test(email.toLowerCase());\n};\n\n// Special login handling for test accounts\nexport const loginTestUser = async (email: string, password: string) => {\n  try {\n    console.log(`[supabaseClient] Logging in test user: ${email}`);\n\n    // Check if this is an email that should be handled specially\n    if (!isTestEmail(email)) {\n      console.warn('[supabaseClient] This is not a test email, should use regular login');\n      return { error: new Error('Not a test email') };\n    }\n\n    // Check if this user is a group admin based on email\n    const isGroupAdminEmail =\n      email.toLowerCase().includes('group') && email.toLowerCase().includes('@exampletest.com');\n\n    if (isGroupAdminEmail) {\n      console.log(`[supabaseClient] ${email} - detected as a group admin by email pattern`);\n\n      // Force direct redirection for group admin test users, preventing any redirect loops\n      localStorage.setItem('force_redirect_after_login', '/group-admin');\n      localStorage.setItem('force_redirect_timestamp', Date.now().toString());\n    }\n\n    // Try regular sign-in first\n    const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({\n      email,\n      password,\n      options: {\n        // Keep this session for testing\n        persistSession: true,\n      },\n    });\n\n    // If sign-in worked without errors, return the session data\n    if (!signInError && signInData?.user) {\n      console.log(`[supabaseClient] Sign-in successful for ${email}, checking group admin status`);\n\n      // For group admin emails, ensure the flag is set regardless of database state\n      if (isGroupAdminEmail) {\n        console.log(`[supabaseClient] Setting group admin metadata for ${email}`);\n\n        try {\n          // First update the user metadata\n          const { data: userUpdateData, error: userUpdateError } = await supabase.auth.updateUser({\n            data: {\n              is_group_admin: true,\n              role: 'dealer_group_admin',\n            },\n          });\n\n          if (userUpdateError) {\n            console.warn('[supabaseClient] Could not update user metadata:', userUpdateError);\n          } else {\n            console.log('[supabaseClient] Updated user metadata for group admin:', userUpdateData);\n          }\n\n          // Then update the profile record\n          const { error: profileError } = await supabase\n            .from('profiles')\n            .update({\n              is_group_admin: true,\n              role: 'dealer_group_admin',\n            })\n            .eq('id', signInData.user.id);\n\n          if (profileError) {\n            console.warn('[supabaseClient] Could not update profile:', profileError);\n          } else {\n            console.log('[supabaseClient] Updated profile for group admin');\n          }\n        } catch (err) {\n          console.error('[supabaseClient] Error setting group admin status:', err);\n        }\n\n        // IMMEDIATE REDIRECT: Force direct navigation for group admin test users\n        console.log('[supabaseClient] Performing immediate redirect for group admin test user');\n\n        // Set a session flag to indicate this is a valid redirect, not a cross-site one\n        sessionStorage.setItem('auth_redirect_authorized', 'true');\n\n        // Short timeout to ensure the session is established before redirect\n        setTimeout(() => {\n          // Redirect to our special redirect page instead of directly to group-admin\n          window.location.href = '/test-login-redirect';\n        }, 500);\n\n        // Force direct redirect via custom metadata\n        return {\n          data: {\n            ...signInData,\n            user: {\n              ...signInData.user,\n              user_metadata: {\n                ...signInData.user.user_metadata,\n                is_group_admin: true,\n                role: 'dealer_group_admin',\n              },\n            },\n          },\n          isGroupAdmin: true,\n          forceRedirect: true,\n          redirectPath: '/test-login-redirect',\n          message: 'Group admin test user logged in successfully',\n        };\n      }\n\n      // For non-group admin accounts, proceed with regular checks\n      console.log(`[supabaseClient] Checking group admin status for ${email}`);\n      try {\n        const { data, error } = await supabase\n          .from('profiles')\n          .select('is_group_admin, role, dealership_id')\n          .eq('id', signInData.user.id)\n          .maybeSingle();\n\n        console.log(`[supabaseClient] Test user profile data:`, data);\n\n        if (data?.is_group_admin) {\n          console.log(`[supabaseClient] User ${email} is a group admin`);\n\n          // Add metadata to the test user for easier debugging\n          const { data: userUpdateData, error: userUpdateError } = await supabase.auth.updateUser({\n            data: {\n              is_group_admin: true,\n              role: data.role || 'dealer_group_admin',\n            },\n          });\n\n          if (userUpdateError) {\n            console.warn('[supabaseClient] Could not update user metadata:', userUpdateError);\n          } else {\n            console.log('[supabaseClient] Updated user metadata for group admin');\n          }\n\n          // Return with isGroupAdmin flag set\n          return {\n            data: signInData,\n            isGroupAdmin: true,\n            message: 'Group admin test user logged in successfully',\n          };\n        }\n      } catch (profileError) {\n        console.error('[supabaseClient] Error checking group admin status:', profileError);\n      }\n\n      return {\n        data: signInData,\n        message: 'Test user logged in successfully',\n      };\n    }\n\n    // If regular sign-in worked, just return the data\n    if (signInData?.session) {\n      return {\n        data: signInData,\n        message: 'Test user logged in successfully',\n      };\n    }\n\n    return { error: signInError, message: 'Failed to log in test user' };\n  } catch (error) {\n    console.error('[supabaseClient] Exception in loginTestUser:', error);\n    return {\n      error: error instanceof Error ? error : new Error('Unknown error during test login'),\n    };\n  }\n};\n\nexport interface Deal {\n  id?: string;\n  stock_number: string;\n  vin_last8: string;\n  new_or_used: VehicleType;\n  customer_last_name: string;\n  deal_type: DealType;\n  reserve_flat_amount: number | null;\n  vsc_profit: number | null;\n  ppm_profit: number | null;\n  tire_wheel_profit: number | null;\n  paint_fabric_profit: number | null;\n  other_profit: number | null;\n  front_end_gross: number;\n  status: DealStatus;\n  created_by?: string;\n  sales_manager_id?: string | null;\n  fi_manager_id?: string;\n  salesperson_id?: string;\n  salesperson_initials?: string;\n  created_at?: string;\n  updated_at?: string;\n  funded_at?: string | null;\n  unwound_at?: string | null;\n}\n\nexport type User = {\n  id: string;\n  first_name: string;\n  last_name: string;\n  email: string;\n  role_id: string;\n  created_by: string;\n  created_at: string;\n};\n\nexport type PayPlan = {\n  id: string;\n  role_id: string;\n  front_end_percent: number;\n  back_end_percent: number;\n  csi_bonus: number;\n  demo_allowance: number;\n  vsc_bonus: number;\n  ppm_bonus: number;\n  volume_bonus: Record<string, number>;\n  updated_by: string;\n  updated_at: string;\n};\n\n// Add a debug function to test the Supabase connection\nexport const testSupabaseConnection = async () => {\n  try {\n    console.log('[supabaseClient] Testing Supabase connection', {\n      url: import.meta.env.VITE_SUPABASE_URL,\n      keyFirstChars: import.meta.env.VITE_SUPABASE_ANON_KEY?.substring(0, 5) + '...',\n    });\n\n    // Try a simple query\n    const { data, error } = await supabase.from('roles').select('count').limit(1);\n\n    if (error) {\n      console.error('[supabaseClient] Connection test failed:', error);\n      return {\n        success: false,\n        error: error,\n      };\n    }\n\n    console.log('[supabaseClient] Connection test successful:', data);\n    return {\n      success: true,\n      data: data,\n    };\n  } catch (err) {\n    console.error('[supabaseClient] Exception in connection test:', err);\n    return {\n      success: false,\n      error: err,\n    };\n  }\n};\n\n/**\n * Creates a test user account that doesn't require email verification.\n * Use this for testing purposes only.\n */\nexport const createTestUser = async (email: string, password: string, userData: any) => {\n  try {\n    console.log(`[supabaseClient] Creating test user: ${email}`);\n\n    // For test domains, we want to explicitly bypass verification\n    const isTestDomain =\n      email.endsWith('@exampletest.com') ||\n      email.endsWith('@example.com') ||\n      email.includes('test');\n\n    if (!isTestDomain) {\n      console.warn(\n        '[supabaseClient] Warning: Creating account with non-test domain may require email verification'\n      );\n    }\n\n    // 1. First, sign up the user normally\n    const { data: signUpData, error: signUpError } = await supabase.auth.signUp({\n      email,\n      password,\n      options: {\n        data: userData,\n        // For test accounts, request no email confirmation\n        emailRedirectTo: window.location.origin,\n      },\n    });\n\n    if (signUpError) {\n      console.error('[supabaseClient] Error creating test user:', signUpError);\n      return { error: signUpError };\n    }\n\n    if (!signUpData.user) {\n      console.error('[supabaseClient] No user returned from sign up');\n      return { error: new Error('No user returned from sign up') };\n    }\n\n    const userId = signUpData.user.id;\n    console.log('[supabaseClient] User created with ID:', userId);\n\n    // For test domains, attempt to auto-verify using admin functions\n    if (isTestDomain) {\n      // 2. Try to directly set email_confirmed_at in auth.users via RPC\n      try {\n        console.log('[supabaseClient] Attempting to auto-confirm test account');\n\n        // Try force_confirm_email RPC if it exists\n        const { data: rpcData, error: rpcError } = await supabase.rpc('force_confirm_email', {\n          user_id_param: userId,\n        });\n\n        if (rpcError) {\n          console.warn('[supabaseClient] RPC confirmation failed:', rpcError);\n\n          // Try a different RPC function name if the first one failed\n          try {\n            const { data: rpc2Data, error: rpc2Error } = await supabase.rpc('admin_confirm_user', {\n              user_id: userId,\n            });\n\n            if (rpc2Error) {\n              console.warn('[supabaseClient] Second RPC confirmation failed:', rpc2Error);\n            } else {\n              console.log('[supabaseClient] Second RPC confirmation successful');\n            }\n          } catch (rpc2Err) {\n            console.warn('[supabaseClient] Second RPC exception:', rpc2Err);\n          }\n        } else {\n          console.log('[supabaseClient] RPC confirmation successful');\n        }\n\n        // Admin API approach - may not work without proper permissions\n        try {\n          const { data: adminData, error: adminError } = await supabase.auth.admin.updateUserById(\n            userId,\n            { email_confirm: true }\n          );\n\n          if (adminError) {\n            console.warn('[supabaseClient] Admin API confirmation failed:', adminError);\n          } else {\n            console.log('[supabaseClient] Admin API confirmation successful');\n          }\n        } catch (adminErr) {\n          console.warn('[supabaseClient] Admin API exception:', adminErr);\n        }\n      } catch (rpcError) {\n        console.warn('[supabaseClient] RPC confirmation exception:', rpcError);\n      }\n    }\n\n    // 3. Try to upsert into the profiles table to ensure profile exists\n    try {\n      const { error: profileError } = await supabase.from('profiles').upsert([\n        {\n          id: userId,\n          email,\n          name: userData.name || email.split('@')[0],\n          role: userData.role || 'salesperson',\n          dealership_id: userData.dealership_id || 1,\n          is_test_account: true,\n        },\n      ]);\n\n      if (profileError) {\n        console.warn('[supabaseClient] Profile creation warning:', profileError);\n      } else {\n        console.log('[supabaseClient] Profile created successfully');\n      }\n    } catch (profileError) {\n      console.warn('[supabaseClient] Profile creation exception:', profileError);\n    }\n\n    // Return the created user with helpful information\n    return {\n      data: signUpData.user,\n      credentials: {\n        email,\n        password,\n        role: userData.role || 'salesperson',\n        dealership_id: userData.dealership_id || 1,\n      },\n      needsConfirmation: !isTestDomain,\n      message: isTestDomain\n        ? 'Test user created with automatic verification attempted.'\n        : 'User created. Email confirmation might still be required.',\n    };\n  } catch (error) {\n    console.error('[supabaseClient] Exception creating test user:', error);\n    return {\n      error: error instanceof Error ? error : new Error('Unknown error creating test user'),\n    };\n  }\n};\n","/**\n * API Service\n * Provides functions to interact with the Supabase API\n */\n\nimport { supabase, getUserSession, getCurrentUser } from './supabaseClient';\nimport type { User } from '@supabase/supabase-js';\n\n// Types\ninterface SignInCredentials {\n  email: string;\n  password: string;\n}\n\ninterface SignUpCredentials extends SignInCredentials {\n  name?: string;\n  role?: string;\n  dealership_id?: string;\n}\n\ninterface AuthResponse {\n  user: User | null;\n  session: any | null;\n  error?: Error | null;\n}\n\nexport interface Sale {\n  id: string;\n  dealership_id: string;\n  sale_date: string;\n  amount: number;\n  // Add other sale fields as needed\n}\n\nexport interface Metric {\n  id: string;\n  dealership_id: string;\n  metric_date: string;\n  value: number;\n  type: string;\n  // Add other metric fields as needed\n}\n\nexport interface FniDetail {\n  id: string;\n  sale_id: string;\n  product_type: string;\n  amount: number;\n  // Add other F&I fields as needed\n}\n\nexport interface DealershipGroup {\n  id: number;\n  name: string;\n  logo_url?: string;\n  brands?: string | string[]; // Can be either a JSON string or an array of strings\n  created_at?: string;\n}\n\nexport interface Dealership {\n  id: number;\n  name: string;\n  group_id?: number;\n  schema_name: string;\n  logo_url?: string;\n  locations?: any[];\n  brands?: string[];\n  created_at?: string;\n}\n\nexport interface Role {\n  id: number;\n  name: string;\n  description?: string;\n}\n\nexport interface SignupRequest {\n  id: string;\n  dealership_name: string;\n  contact_person: string;\n  email: string;\n  tier: 'free_trial' | 'finance_manager' | 'dealership' | 'dealer_group';\n  add_ons?: string[]; // For storing + Version and ++ Version add-ons\n  stripe_subscription_id?: string;\n  status: 'pending' | 'approved' | 'rejected';\n  created_at: string;\n  updated_at: string;\n  processed_at?: string;\n  processed_by?: string;\n}\n\n// Base API configuration\nconst API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';\n\n// Helper to handle API responses\nconst handleResponse = async (response: Response) => {\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || 'API request failed');\n  }\n  return response.json();\n};\n\n// Get auth headers for API requests\nconst getAuthHeaders = async () => {\n  const user = await getCurrentUser();\n  if (!user) {\n    throw new Error('No authenticated user');\n  }\n\n  const {\n    data: { session },\n    error,\n  } = await supabase.auth.getSession();\n  if (error || !session) {\n    throw new Error('Failed to get auth session');\n  }\n\n  return {\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${session.access_token}`,\n  };\n};\n\n// Generic API request function with auth\nexport const apiRequest = async <T>(endpoint: string, options: RequestInit = {}): Promise<T> => {\n  try {\n    const headers = await getAuthHeaders();\n    const response = await fetch(`${API_URL}${endpoint}`, {\n      ...options,\n      headers: {\n        ...headers,\n        ...options.headers,\n      },\n    });\n    return handleResponse(response);\n  } catch (error) {\n    console.error('API request failed:', error);\n    throw error;\n  }\n};\n\n// Example API methods\nexport const getDealershipBasicInfo = async (dealershipId: string) => {\n  return apiRequest(`/dealerships/${dealershipId}`);\n};\n\nexport const updateDealershipData = async (dealershipId: string, data: any) => {\n  return apiRequest(`/dealerships/${dealershipId}`, {\n    method: 'PUT',\n    body: JSON.stringify(data),\n  });\n};\n\nexport const getSalesData = async (dealershipId: string, params?: Record<string, string>) => {\n  const queryString = params ? new URLSearchParams(params).toString() : '';\n  return apiRequest(`/dealerships/${dealershipId}/sales${queryString ? `?${queryString}` : ''}`);\n};\n\nexport const getMetrics = async (dealershipId: string, timeframe?: string) => {\n  const query = timeframe ? `?timeframe=${timeframe}` : '';\n  return apiRequest(`/dealerships/${dealershipId}/metrics${query}`);\n};\n\nexport const getFniDetails = async (dealershipId: string, params?: Record<string, string>) => {\n  const queryString = params ? new URLSearchParams(params).toString() : '';\n  return apiRequest(`/dealerships/${dealershipId}/fni${queryString ? `?${queryString}` : ''}`);\n};\n\n// Authentication Functions\nexport async function signIn(credentials: SignInCredentials): Promise<AuthResponse> {\n  try {\n    console.log('Attempting sign in for:', credentials.email);\n\n    const { data, error } = await supabase.auth.signInWithPassword({\n      email: credentials.email,\n      password: credentials.password,\n    });\n\n    if (error) {\n      console.error('Sign in error:', error);\n      throw error;\n    }\n\n    if (!data.user) {\n      throw new Error('No user returned from authentication');\n    }\n\n    // Get the user profile from the profiles table\n    const { data: profileData, error: profileError } = await supabase\n      .from('profiles')\n      .select('*')\n      .eq('id', data.user.id)\n      .single();\n\n    if (profileError) {\n      console.error('Profile fetch error:', profileError);\n    }\n\n    // Combine auth user with profile data\n    const userWithProfile = profileData ? { ...data.user, ...profileData } : data.user;\n\n    console.log('Sign in successful:', { userId: data.user.id });\n\n    return {\n      user: userWithProfile,\n      session: data.session,\n    };\n  } catch (error) {\n    console.error('Sign in failed:', error);\n    throw error;\n  }\n}\n\nexport async function signUp(credentials: SignUpCredentials): Promise<AuthResponse> {\n  try {\n    const { data, error } = await supabase.auth.signUp({\n      email: credentials.email,\n      password: credentials.password,\n      options: {\n        data: {\n          name: credentials.name,\n          role: credentials.role,\n          dealership_id: credentials.dealership_id,\n        },\n      },\n    });\n\n    if (error) {\n      console.error('Sign up error:', error);\n      throw error;\n    }\n\n    return {\n      user: data.user,\n      session: data.session,\n    };\n  } catch (error) {\n    console.error('Sign up failed:', error);\n    throw error;\n  }\n}\n\nexport async function signOut(): Promise<void> {\n  const { error } = await supabase.auth.signOut();\n  if (error) {\n    console.error('Sign out error:', error);\n    throw error;\n  }\n}\n\nexport async function getProfile(): Promise<User | null> {\n  try {\n    const user = await getCurrentUser();\n    if (!user) {\n      console.log('No authenticated user found');\n      return null;\n    }\n\n    const { data, error } = await supabase.from('profiles').select('*').eq('id', user.id).single();\n\n    if (error) {\n      console.error('Profile fetch error:', error);\n      return user;\n    }\n\n    return {\n      ...user,\n      ...data,\n    };\n  } catch (error) {\n    console.error('Get profile error:', error);\n    return null;\n  }\n}\n\n// Sales Functions\nexport async function getSales(dealershipId?: string): Promise<Sale[]> {\n  try {\n    let query = supabase.from('sales').select('*');\n    if (dealershipId) {\n      query = query.eq('dealership_id', dealershipId);\n    }\n    const { data, error } = await query;\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('Get sales error:', error);\n    throw error;\n  }\n}\n\nexport async function createSale(sale: Omit<Sale, 'id'>): Promise<Sale> {\n  const { data, error } = await supabase.from('sales').insert([sale]).select().single();\n\n  if (error) throw error;\n  return data;\n}\n\n// Metrics Functions\nexport async function getMetricsData(dealershipId?: string, timeframe?: string): Promise<Metric[]> {\n  try {\n    let query = supabase.from('metrics').select('*');\n    if (dealershipId) {\n      query = query.eq('dealership_id', dealershipId);\n    }\n    if (timeframe) {\n      query = query.gte('metric_date', timeframe);\n    }\n    const { data, error } = await query;\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('Get metrics error:', error);\n    throw error;\n  }\n}\n\n// F&I Functions\nexport async function getFniData(saleId?: string): Promise<FniDetail[]> {\n  try {\n    let query = supabase.from('fni_details').select('*');\n    if (saleId) {\n      query = query.eq('sale_id', saleId);\n    }\n    const { data, error } = await query;\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('Get F&I details error:', error);\n    throw error;\n  }\n}\n\n// Dealership Functions\nexport async function getBasicDealerships() {\n  const { data, error } = await supabase.from('dealerships').select('*');\n\n  if (error) throw error;\n  return data;\n}\n\n// General data fetching function\nexport async function getData(table: string) {\n  const { data, error } = await supabase.from(table).select('*');\n\n  if (error) throw error;\n  return data;\n}\n\n// Connection test\nexport async function testConnection(): Promise<boolean> {\n  try {\n    const { data, error } = await supabase\n      .from('profiles')\n      .select('count', { count: 'exact', head: true });\n    return !error;\n  } catch (error) {\n    console.error('Connection test failed:', error);\n    return false;\n  }\n}\n\n// Dealership Group functions\nexport const getDealershipGroups = async () => {\n  try {\n    console.log('[apiService] Fetching dealership groups');\n    const { data, error } = await supabase\n      .from('dealership_groups')\n      .select('*') // Fetch all columns including brands and brands_list\n      .order('name');\n\n    if (error) {\n      console.error('[apiService] Error fetching dealership groups:', error);\n      throw error;\n    }\n\n    // For debugging, log the structure of the first group if available\n    if (data && data.length > 0) {\n      console.log('[apiService] First group structure:', data[0]);\n    }\n\n    console.log(`[apiService] Fetched ${data?.length || 0} dealership groups`);\n    return data;\n  } catch (error) {\n    console.error('[apiService] Exception in getDealershipGroups:', error);\n    throw error;\n  }\n};\n\nexport const createDealershipGroup = async groupData => {\n  try {\n    console.log('[apiService] Creating dealership group:', groupData);\n\n    // Create a copy of the data to avoid modifying the original\n    const dataToInsert = { ...groupData };\n\n    // Handle brands properly - ensure it's stored as a plain string in the database\n    if (dataToInsert.brands) {\n      if (Array.isArray(dataToInsert.brands)) {\n        console.log('[apiService] Brands provided as array, converting to string');\n        // Join the array into a comma-separated string instead of using JSON.stringify\n        dataToInsert.brands = dataToInsert.brands.join(',');\n      } else if (typeof dataToInsert.brands === 'string') {\n        console.log('[apiService] Brands provided as string:', dataToInsert.brands);\n        // Keep as is\n      }\n    }\n\n    const { data, error } = await supabase\n      .from('dealership_groups')\n      .insert(dataToInsert)\n      .select()\n      .single();\n\n    if (error) {\n      console.error('[apiService] Error creating dealership group:', error);\n      console.error('[apiService] Error details:', {\n        message: error.message,\n        code: error.code,\n        details: error.details,\n        hint: error.hint,\n      });\n\n      // Log full error as string for more details\n      console.error('[apiService] Full error JSON:', JSON.stringify(error, null, 2));\n\n      throw error;\n    }\n\n    console.log('[apiService] Created dealership group successfully:', data);\n    return data;\n  } catch (error) {\n    console.error('[apiService] Exception in createDealershipGroup:', error);\n    if (error instanceof Error) {\n      console.error('[apiService] Error message:', error.message);\n      console.error('[apiService] Error stack:', error.stack);\n    }\n\n    // Try to stringify the entire error object\n    try {\n      console.error(\n        '[apiService] Full error object:',\n        JSON.stringify(error, Object.getOwnPropertyNames(error))\n      );\n    } catch (e) {\n      console.error('[apiService] Could not stringify error object');\n    }\n\n    throw error;\n  }\n};\n\n// Dealership functions\nexport const getDealerships = async (groupId?: number) => {\n  try {\n    console.log('[apiService] Fetching dealerships', groupId ? `for group ${groupId}` : '');\n    let query = supabase.from('dealerships').select('*, dealership_groups(name)').order('name');\n\n    if (groupId) {\n      query = query.eq('group_id', groupId);\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      console.error('[apiService] Error fetching dealerships:', error);\n      throw error;\n    }\n\n    console.log('[apiService] Fetched dealerships:', data);\n    return data;\n  } catch (error) {\n    console.error('[apiService] Exception in getDealerships:', error);\n    throw error;\n  }\n};\n\nexport const createDealership = async (dealershipData: Omit<Dealership, 'id'>) => {\n  try {\n    console.log('[apiService] Creating dealership, data:', dealershipData);\n\n    // Generate schema name if not provided\n    if (!dealershipData.schema_name) {\n      dealershipData.schema_name = `dealership_${Date.now()}`;\n    }\n\n    // Ensure group_id is handled correctly\n    if (dealershipData.group_id) {\n      console.log(`[apiService] Assigning dealership to group: ${dealershipData.group_id}`);\n    } else {\n      console.log('[apiService] No group assigned for this dealership');\n      // Make sure null is passed and not undefined to avoid database errors\n      dealershipData.group_id = null;\n    }\n\n    // Store brands properly\n    if (dealershipData.brands && typeof dealershipData.brands === 'string') {\n      console.log('[apiService] Brands provided as string:', dealershipData.brands);\n      // Already a JSON string, no need to convert\n    } else if (Array.isArray(dealershipData.brands)) {\n      console.log('[apiService] Brands provided as array, converting to JSON');\n      dealershipData.brands = JSON.stringify(dealershipData.brands);\n    }\n\n    // Log the final data being sent to database\n    console.log(\n      '[apiService] Final dealership data for DB:',\n      JSON.stringify(dealershipData, null, 2)\n    );\n\n    const { data, error } = await supabase\n      .from('dealerships')\n      .insert(dealershipData)\n      .select()\n      .single();\n\n    if (error) {\n      console.error('[apiService] Error creating dealership:', error);\n      console.error('[apiService] Error details:', {\n        message: error.message,\n        code: error.code,\n        details: error.details,\n        hint: error.hint,\n      });\n      throw error;\n    }\n\n    console.log('[apiService] Created dealership successfully:', data);\n    return data;\n  } catch (error) {\n    console.error('[apiService] Exception in createDealership:', error);\n    if (error instanceof Error) {\n      console.error('[apiService] Error message:', error.message);\n      console.error('[apiService] Error stack:', error.stack);\n    }\n    throw error;\n  }\n};\n\n// Roles functions\nexport const getRoles = async () => {\n  try {\n    console.log('[apiService] Fetching roles');\n    const { data, error } = await supabase.from('roles').select('*').order('id');\n\n    if (error) {\n      console.error('[apiService] Error fetching roles:', error);\n      throw error;\n    }\n\n    console.log('[apiService] Fetched roles:', data);\n    return data;\n  } catch (error) {\n    console.error('[apiService] Exception in getRoles:', error);\n    throw error;\n  }\n};\n\n// User functions\nexport const updateUserRole = async (userId: string, roleId: number, dealershipId?: number) => {\n  try {\n    console.log(\n      `[apiService] Updating user ${userId} with role ${roleId} and dealership ${\n        dealershipId || 'none'\n      }`\n    );\n\n    const updateData: { role_id: number; dealership_id?: number } = {\n      role_id: roleId,\n    };\n\n    if (dealershipId) {\n      updateData.dealership_id = dealershipId;\n    }\n\n    const { data, error } = await supabase\n      .from('profiles')\n      .update(updateData)\n      .eq('id', userId)\n      .select()\n      .single();\n\n    if (error) {\n      console.error('[apiService] Error updating user role:', error);\n      throw error;\n    }\n\n    console.log('[apiService] Updated user role:', data);\n    return data;\n  } catch (error) {\n    console.error('[apiService] Exception in updateUserRole:', error);\n    throw error;\n  }\n};\n\n// Dealership-specific data functions\nexport const getDealershipData = async <T>(\n  dealershipId: number,\n  table: string,\n  columns: string = '*'\n): Promise<T[]> => {\n  try {\n    console.log(`[apiService] Fetching ${table} data for dealership ${dealershipId}`);\n\n    // First, get the schema name for this dealership\n    const { data: dealership, error: dealershipError } = await supabase\n      .from('dealerships')\n      .select('schema_name')\n      .eq('id', dealershipId)\n      .single();\n\n    if (dealershipError) {\n      console.error('[apiService] Error fetching dealership schema:', dealershipError);\n      throw dealershipError;\n    }\n\n    if (!dealership) {\n      console.error(`[apiService] Dealership with ID ${dealershipId} not found`);\n      throw new Error(`Dealership with ID ${dealershipId} not found`);\n    }\n\n    // Query the table in the dealership's schema\n    const { data, error } = await supabase\n      .from(`${dealership.schema_name}.${table}`)\n      .select(columns);\n\n    if (error) {\n      console.error(`[apiService] Error fetching ${table} data:`, error);\n      throw error;\n    }\n\n    console.log(`[apiService] Fetched ${table} data:`, data);\n    return data as T[];\n  } catch (error) {\n    console.error(`[apiService] Exception in getDealershipData for ${table}:`, error);\n    throw error;\n  }\n};\n\nexport const createDealershipRecord = async <T>(\n  dealershipId: number,\n  table: string,\n  recordData: any\n): Promise<T> => {\n  try {\n    console.log(\n      `[apiService] Creating ${table} record for dealership ${dealershipId}:`,\n      recordData\n    );\n\n    // First, get the schema name for this dealership\n    const { data: dealership, error: dealershipError } = await supabase\n      .from('dealerships')\n      .select('schema_name')\n      .eq('id', dealershipId)\n      .single();\n\n    if (dealershipError) {\n      console.error('[apiService] Error fetching dealership schema:', dealershipError);\n      throw dealershipError;\n    }\n\n    if (!dealership) {\n      console.error(`[apiService] Dealership with ID ${dealershipId} not found`);\n      throw new Error(`Dealership with ID ${dealershipId} not found`);\n    }\n\n    // Insert the record into the dealership's schema\n    const { data, error } = await supabase\n      .from(`${dealership.schema_name}.${table}`)\n      .insert(recordData)\n      .select()\n      .single();\n\n    if (error) {\n      console.error(`[apiService] Error creating ${table} record:`, error);\n      throw error;\n    }\n\n    console.log(`[apiService] Created ${table} record:`, data);\n    return data as T;\n  } catch (error) {\n    console.error(`[apiService] Exception in createDealershipRecord for ${table}:`, error);\n    throw error;\n  }\n};\n\n// Debug functions\nexport const logSchemaOperation = async (action: string, details: any) => {\n  try {\n    console.log(`[apiService] Logging schema operation: ${action}`, details);\n\n    // Check if the logs table exists first\n    try {\n      const { data, error } = await supabase\n        .from('logs')\n        .insert({\n          action,\n          details,\n        })\n        .select()\n        .single();\n\n      if (error) {\n        console.log(\n          '[apiService] Error logging schema operation, continuing silently:',\n          error.message\n        );\n        return true; // Don't fail the operation just because logging failed\n      }\n\n      console.log('[apiService] Logged schema operation:', data);\n      return true;\n    } catch (innerError) {\n      console.log('[apiService] Schema operation logging failed, continuing silently');\n      return true; // Don't fail the operation just because logging failed\n    }\n  } catch (error) {\n    console.log('[apiService] Exception in logSchemaOperation, continuing silently');\n    return true; // Don't fail the operation just because logging failed\n  }\n};\n\nexport const testSchemaConnections = async () => {\n  try {\n    console.log('[apiService] Testing schema connections');\n\n    // Test global tables\n    const { data: groups, error: groupsError } = await supabase\n      .from('dealership_groups')\n      .select('count(*)');\n\n    if (groupsError) {\n      throw new Error(`Error connecting to dealership_groups: ${groupsError.message}`);\n    }\n\n    const { data: dealerships, error: dealershipsError } = await supabase\n      .from('dealerships')\n      .select('count(*)');\n\n    if (dealershipsError) {\n      throw new Error(`Error connecting to dealerships: ${dealershipsError.message}`);\n    }\n\n    // Get first dealership to test schema\n    const { data: firstDealership, error: firstDealershipError } = await supabase\n      .from('dealerships')\n      .select('schema_name')\n      .limit(1)\n      .single();\n\n    let schemaTestResult = { success: false, message: 'No dealerships found' };\n\n    if (firstDealership) {\n      try {\n        // Try to query a table in the dealership's schema\n        const { data: schemaTest, error: schemaTestError } = await supabase\n          .from(`${firstDealership.schema_name}.pay_plans`)\n          .select('count(*)');\n\n        if (schemaTestError) {\n          schemaTestResult = {\n            success: false,\n            message: `Error connecting to ${firstDealership.schema_name}: ${schemaTestError.message}`,\n          };\n        } else {\n          schemaTestResult = {\n            success: true,\n            message: `Successfully connected to ${firstDealership.schema_name}`,\n          };\n        }\n      } catch (schemaError) {\n        schemaTestResult = {\n          success: false,\n          message: `Exception connecting to ${firstDealership.schema_name}: ${String(schemaError)}`,\n        };\n      }\n    }\n\n    const results = {\n      globalTables: {\n        groups: { success: true, count: groups[0].count },\n        dealerships: { success: true, count: dealerships[0].count },\n      },\n      dealershipSchema: schemaTestResult,\n    };\n\n    console.log('[apiService] Schema connection test results:', results);\n    return results;\n  } catch (error) {\n    console.error('[apiService] Exception in testSchemaConnections:', error);\n    return {\n      globalTables: { success: false, message: String(error) },\n      dealershipSchema: { success: false, message: 'Could not test dealership schema' },\n    };\n  }\n};\n\n// New functions for dealership project management\n\n/**\n * Fetches the Supabase URL and anon key for a dealership project\n */\nexport const getDealershipSupabaseConfig = async (dealershipId: number) => {\n  try {\n    console.log('Fetching Supabase config for dealership:', dealershipId);\n    const { data, error } = await supabase\n      .from('dealerships')\n      .select('id, name, schema_name, supabase_url, supabase_key')\n      .eq('id', dealershipId)\n      .single();\n\n    if (error) {\n      console.error('Error fetching dealership Supabase config:', error);\n      throw error;\n    }\n\n    if (!data) {\n      throw new Error(`No dealership found with ID ${dealershipId}`);\n    }\n\n    if (!data.supabase_url || !data.supabase_key) {\n      // If the keys are not in the database, use the environment variables based on schema_name\n      const schemaName = data.schema_name || `dealership_${dealershipId}`;\n      const envUrlKey = `VITE_${schemaName.toUpperCase()}_SUPABASE_URL`;\n      const envAnonKey = `VITE_${schemaName.toUpperCase()}_SUPABASE_ANON_KEY`;\n\n      // Try to get from environment\n      const url = import.meta.env[envUrlKey] || '';\n      const key = import.meta.env[envAnonKey] || '';\n\n      if (!url || !key) {\n        console.warn(\n          `No Supabase config found for dealership ${dealershipId} in either database or environment`\n        );\n        return null;\n      }\n\n      return {\n        id: data.id,\n        name: data.name,\n        schema_name: schemaName,\n        supabase_url: url,\n        supabase_key: key,\n      };\n    }\n\n    return data;\n  } catch (error) {\n    console.error('Failed to get dealership Supabase config:', error);\n    return null;\n  }\n};\n\n/**\n * Test connection to a dealership's Supabase project\n */\nexport const testDealershipConnection = async (dealershipId: number) => {\n  try {\n    const config = await getDealershipSupabaseConfig(dealershipId);\n    if (!config || !config.supabase_url || !config.supabase_key) {\n      return { success: false, message: 'Missing Supabase configuration for this dealership' };\n    }\n\n    // Create a temporary client\n    const tempClient = createClient(config.supabase_url, config.supabase_key);\n\n    // Test the connection by fetching the PostgreSQL version\n    const { data, error } = await tempClient.rpc('get_pg_version');\n\n    if (error) {\n      console.error('Error testing dealership connection:', error);\n      return {\n        success: false,\n        message: `Connection failed: ${error.message}`,\n        error,\n      };\n    }\n\n    return {\n      success: true,\n      message: 'Connection successful',\n      data,\n      config,\n    };\n  } catch (error) {\n    console.error('Failed to test dealership connection:', error);\n    return {\n      success: false,\n      message: `Connection test failed: ${error}`,\n      error,\n    };\n  }\n};\n\n/**\n * Create a user in a dealership's Supabase project\n */\nexport const createDealershipUser = async (\n  dealershipId: number,\n  userData: {\n    email: string;\n    password: string;\n    first_name: string;\n    last_name: string;\n    role_id: string;\n    phone_number?: string;\n  }\n) => {\n  try {\n    console.log(`Creating user in dealership ${dealershipId}:`, {\n      email: userData.email,\n      name: `${userData.first_name} ${userData.last_name}`,\n      role: userData.role_id,\n    });\n\n    // First, test the connection to ensure we have access\n    const connectionTest = await testDealershipConnection(dealershipId);\n    if (!connectionTest.success) {\n      throw new Error(`Cannot connect to dealership Supabase: ${connectionTest.message}`);\n    }\n\n    // Get the dealership supabase client\n    const dealershipClient = getDealershipSupabase(dealershipId);\n\n    // Create the user in the auth system\n    const { data: authData, error: authError } = await dealershipClient.auth.admin.createUser({\n      email: userData.email,\n      password: userData.password,\n      email_confirm: true,\n      user_metadata: {\n        first_name: userData.first_name,\n        last_name: userData.last_name,\n        full_name: `${userData.first_name} ${userData.last_name}`,\n        role_id: userData.role_id,\n        dealership_id: dealershipId,\n      },\n    });\n\n    if (authError) {\n      console.error('Error creating user in auth system:', authError);\n      throw authError;\n    }\n\n    if (!authData.user) {\n      throw new Error('User creation failed - no user returned');\n    }\n\n    // Add user to the public.users table\n    const { data: userData, error: userError } = await dealershipClient\n      .from('users')\n      .insert({\n        id: authData.user.id,\n        first_name: userData.first_name,\n        last_name: userData.last_name,\n        email: userData.email,\n        role_id: userData.role_id,\n        dealership_id: dealershipId,\n        phone_number: userData.phone_number,\n      })\n      .select()\n      .single();\n\n    if (userError) {\n      console.error('Error adding user to public.users table:', userError);\n\n      // Try to clean up the auth user if possible\n      try {\n        await dealershipClient.auth.admin.deleteUser(authData.user.id);\n      } catch (cleanupError) {\n        console.error('Error cleaning up auth user after failure:', cleanupError);\n      }\n\n      throw userError;\n    }\n\n    // Log the successful creation\n    await logSchemaOperation('create_dealership_user', {\n      dealership_id: dealershipId,\n      user_id: authData.user.id,\n      email: userData.email,\n      role_id: userData.role_id,\n    });\n\n    return {\n      success: true,\n      user: {\n        ...authData.user,\n        ...userData,\n      },\n    };\n  } catch (error) {\n    console.error(`Failed to create user in dealership ${dealershipId}:`, error);\n    return {\n      success: false,\n      error,\n    };\n  }\n};\n\n/**\n * Get users from a specific dealership Supabase project\n */\nexport const getDealershipUsers = async (dealershipId: number) => {\n  try {\n    // Test connection first\n    const connectionTest = await testDealershipConnection(dealershipId);\n    if (!connectionTest.success) {\n      throw new Error(`Cannot connect to dealership Supabase: ${connectionTest.message}`);\n    }\n\n    // Get the dealership client\n    const dealershipClient = getDealershipSupabase(dealershipId);\n\n    // Fetch users\n    const { data, error } = await dealershipClient\n      .from('users')\n      .select(\n        `\n        id, \n        first_name, \n        last_name, \n        email, \n        role_id,\n        phone_number,\n        roles(name)\n      `\n      )\n      .order('last_name', { ascending: true });\n\n    if (error) {\n      console.error(`Error fetching users from dealership ${dealershipId}:`, error);\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error(`Failed to get users from dealership ${dealershipId}:`, error);\n    throw error;\n  }\n};\n\n// Function to create a new schema for a dealership\nexport const createDealershipSchema = async (schemaName: string) => {\n  try {\n    console.log(`[apiService] Creating schema: ${schemaName}`);\n\n    // Create the schema\n    const { error: schemaError } = await supabase.rpc('create_dealership_schema', {\n      schema_name: schemaName,\n    });\n\n    if (schemaError) {\n      console.error('[apiService] Error creating schema:', schemaError);\n      throw schemaError;\n    }\n\n    // Log the creation\n    console.log(`[apiService] Schema ${schemaName} created successfully`);\n\n    return { success: true, message: `Schema ${schemaName} created successfully` };\n  } catch (error) {\n    console.error('[apiService] Exception in createDealershipSchema:', error);\n    throw error;\n  }\n};\n\n// Function to update a dealership's schema name\nexport const updateDealershipSchema = async (dealershipId: number, schemaName: string) => {\n  try {\n    console.log(`[apiService] Updating dealership ${dealershipId} with schema: ${schemaName}`);\n\n    const { data, error } = await supabase\n      .from('dealerships')\n      .update({ schema_name: schemaName })\n      .eq('id', dealershipId)\n      .select()\n      .single();\n\n    if (error) {\n      console.error('[apiService] Error updating dealership schema:', error);\n      throw error;\n    }\n\n    console.log('[apiService] Dealership schema updated:', data);\n    return data;\n  } catch (error) {\n    console.error('[apiService] Exception in updateDealershipSchema:', error);\n    throw error;\n  }\n};\n\n// Dealership group operations\nexport const deleteDealershipGroup = async (groupId: number) => {\n  try {\n    console.log('[apiService] Deleting dealership group:', groupId);\n\n    // First check if there are any dealerships in this group\n    const { data: relatedDealerships, error: checkError } = await supabase\n      .from('dealerships')\n      .select('id')\n      .eq('group_id', groupId);\n\n    if (checkError) {\n      console.error('[apiService] Error checking related dealerships:', checkError);\n      throw checkError;\n    }\n\n    // Don't allow deletion if there are dealerships in this group\n    if (relatedDealerships && relatedDealerships.length > 0) {\n      throw new Error(\n        `Cannot delete group: ${relatedDealerships.length} dealership(s) are associated with this group`\n      );\n    }\n\n    // Delete the group\n    const { error } = await supabase.from('dealership_groups').delete().eq('id', groupId);\n\n    if (error) {\n      console.error('[apiService] Error deleting dealership group:', error);\n      throw error;\n    }\n\n    console.log('[apiService] Successfully deleted dealership group:', groupId);\n    return { success: true };\n  } catch (error) {\n    console.error('[apiService] Exception in deleteDealershipGroup:', error);\n    throw error;\n  }\n};\n\n// Dealership operations\nexport const deleteDealership = async (dealershipId: number) => {\n  try {\n    console.log('[apiService] Deleting dealership:', dealershipId);\n\n    // Get the dealership to find its schema name\n    const { data: dealership, error: getError } = await supabase\n      .from('dealerships')\n      .select('schema_name')\n      .eq('id', dealershipId)\n      .single();\n\n    if (getError) {\n      console.error('[apiService] Error getting dealership before delete:', getError);\n      throw getError;\n    }\n\n    if (!dealership) {\n      throw new Error('Dealership not found');\n    }\n\n    // Delete the dealership\n    const { error: deleteError } = await supabase\n      .from('dealerships')\n      .delete()\n      .eq('id', dealershipId);\n\n    if (deleteError) {\n      console.error('[apiService] Error deleting dealership:', deleteError);\n      throw deleteError;\n    }\n\n    // Note: We're keeping the schema in the database for data recovery purposes\n    // A full schema delete would require admin privileges and should be done carefully\n\n    console.log('[apiService] Successfully deleted dealership:', dealershipId);\n    return { success: true, schemaName: dealership.schema_name };\n  } catch (error) {\n    console.error('[apiService] Exception in deleteDealership:', error);\n    throw error;\n  }\n};\n\n/**\n * Gets pending signup requests\n */\nexport const getSignupRequests = async (): Promise<SignupRequest[]> => {\n  try {\n    console.log('[apiService] Fetching signup requests');\n\n    const { data, error } = await supabase\n      .from('signup_requests')\n      .select('*')\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      console.error('[apiService] Error fetching signup requests:', error);\n      throw error;\n    }\n\n    console.log(`[apiService] Retrieved ${data?.length || 0} signup requests`);\n    return data || [];\n  } catch (error) {\n    console.error('[apiService] Error in getSignupRequests:', error);\n    throw error;\n  }\n};\n\n/**\n * Approves a signup request and creates necessary resources\n */\nexport const approveSignupRequest = async (\n  requestId: string,\n  options: {\n    createSchema?: boolean;\n    schemaName?: string;\n    adminEmail?: string;\n    adminName?: string;\n    tempPassword?: string;\n    addOns?: string[];\n    isDealerGroup?: boolean;\n    groupLevel?: string;\n    dealershipCount?: number;\n  }\n): Promise<{\n  success: boolean;\n  message: string;\n  error?: any;\n  groupId?: number;\n  dealershipIds?: number[];\n}> => {\n  try {\n    console.log(`[apiService] Approving signup request: ${requestId}`);\n    const user = await getCurrentUser();\n\n    if (!user) {\n      throw new Error('Not authenticated');\n    }\n\n    // Get the signup request\n    const { data: requestData, error: requestError } = await supabase\n      .from('signup_requests')\n      .select('*')\n      .eq('id', requestId)\n      .single();\n\n    if (requestError) {\n      console.error(`[apiService] Error fetching signup request: ${requestError.message}`);\n      throw requestError;\n    }\n\n    const request = requestData;\n    console.log('[apiService] Found signup request:', request);\n\n    // First, update request status\n    const { error: updateError } = await supabase\n      .from('signup_requests')\n      .update({ status: 'approved', approved_at: new Date().toISOString() })\n      .eq('id', requestId);\n\n    if (updateError) {\n      console.error(`[apiService] Error updating signup request: ${updateError.message}`);\n      throw updateError;\n    }\n\n    // Group signup management\n    if (options.isDealerGroup) {\n      return await handleDealerGroupSignup(request, options);\n    }\n    // Finance Manager Only signup management\n    else if (request.tier === 'finance_manager_only') {\n      return await handleFinanceManagerSignup(request, options);\n    }\n    // Regular dealership signup management\n    else {\n      console.log(`[apiService] Handling dealership signup for ${request.dealership_name}`);\n\n      // Create schema if requested\n      let schemaName = options.schemaName;\n\n      if (options.createSchema && schemaName) {\n        console.log(`[apiService] Creating schema: ${schemaName}`);\n        const { success: schemaSuccess, error: schemaError } = await createDealershipSchema(\n          schemaName\n        );\n\n        if (!schemaSuccess) {\n          console.error(`[apiService] Error creating schema: ${schemaError}`);\n          throw schemaError;\n        }\n      }\n\n      // Create a dealership record\n      const { data: dealershipData, error: dealershipError } = await supabase\n        .from('dealerships')\n        .insert({\n          name: request.dealership_name,\n          schema_name: schemaName,\n          tier: request.tier,\n          add_ons: request.add_ons || [],\n          status: 'active',\n          contact_email: request.email,\n          contact_name: request.contact_person,\n          contact_phone: request.phone,\n          subscription_status: 'active',\n          created_by: user.id,\n        })\n        .select()\n        .single();\n\n      if (dealershipError) {\n        console.error(`[apiService] Error creating dealership: ${dealershipError.message}`);\n        throw dealershipError;\n      }\n\n      const dealershipId = dealershipData.id;\n      console.log(`[apiService] Created dealership with ID: ${dealershipId}`);\n\n      // Create the dealership admin user if email provided\n      if (options.adminEmail) {\n        console.log(`[apiService] Creating admin user: ${options.adminEmail}`);\n\n        // Check if user already exists\n        const { data: existingUser, error: existingUserError } = await supabase\n          .from('profiles')\n          .select('id')\n          .eq('email', options.adminEmail)\n          .single();\n\n        if (existingUserError && existingUserError.code !== 'PGRST116') {\n          console.error(\n            `[apiService] Error checking for existing user: ${existingUserError.message}`\n          );\n          throw existingUserError;\n        }\n\n        if (existingUser) {\n          console.log(`[apiService] User already exists: ${options.adminEmail}`);\n\n          // Update existing user to add dealership admin role\n          const { error: updateUserError } = await supabase\n            .from('profiles')\n            .update({\n              dealership_id: dealershipId,\n              role: 'dealership_admin',\n            })\n            .eq('email', options.adminEmail);\n\n          if (updateUserError) {\n            console.error(`[apiService] Error updating user: ${updateUserError.message}`);\n            throw updateUserError;\n          }\n        } else {\n          // Create new user\n          const { error: signupError, data: signupData } = await supabase.auth.signUp({\n            email: options.adminEmail,\n            password: options.tempPassword || generatePassword(),\n          });\n\n          if (signupError) {\n            console.error(`[apiService] Error creating user: ${signupError.message}`);\n            throw signupError;\n          }\n\n          // Create profile record\n          const { error: profileError } = await supabase.from('profiles').insert({\n            id: signupData?.user?.id,\n            email: options.adminEmail,\n            dealership_id: dealershipId,\n            role: 'dealership_admin',\n            first_name: options.adminName?.split(' ')[0] || '',\n            last_name: options.adminName?.split(' ').slice(1).join(' ') || '',\n          });\n\n          if (profileError) {\n            console.error(`[apiService] Error creating profile: ${profileError.message}`);\n            throw profileError;\n          }\n        }\n      }\n\n      // Create a subscription event record for billing tracking\n      await recordSubscriptionEvent({\n        dealership_id: dealershipId,\n        event_type: 'signup',\n        tier: request.tier,\n        add_ons: request.add_ons || [],\n        user_id: user.id,\n      });\n\n      console.log(\n        `[apiService] Dealership signup approved and setup complete for ${request.dealership_name}`\n      );\n\n      return {\n        success: true,\n        message: `Dealership ${request.dealership_name} created successfully`,\n        dealershipIds: [dealershipId],\n      };\n    }\n  } catch (error) {\n    console.error('[apiService] Error in approveSignupRequest:', error);\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : 'An unknown error occurred',\n      error,\n    };\n  }\n};\n\n/**\n * Rejects a signup request\n */\nexport const rejectSignupRequest = async (\n  requestId: string,\n  reason?: string\n): Promise<{ success: boolean; message: string; error?: any }> => {\n  try {\n    console.log(`[apiService] Rejecting signup request: ${requestId}`);\n    const user = await getCurrentUser();\n\n    if (!user) {\n      throw new Error('Not authenticated');\n    }\n\n    // Update the request status to 'rejected'\n    const { error: updateError } = await supabase\n      .from('signup_requests')\n      .update({\n        status: 'rejected',\n        processed_at: new Date().toISOString(),\n        processed_by: user.id,\n        // Store rejection reason in additional metadata\n        metadata: { rejection_reason: reason || 'No reason provided' },\n      })\n      .eq('id', requestId);\n\n    if (updateError) {\n      console.error('[apiService] Error updating signup request status:', updateError);\n      throw updateError;\n    }\n\n    return { success: true, message: 'Signup request rejected successfully' };\n  } catch (error) {\n    console.error('[apiService] Error in rejectSignupRequest:', error);\n    return { success: false, message: 'Failed to reject signup request', error };\n  }\n};\n\n/**\n * Generates a random temporary password\n */\nconst generateTemporaryPassword = (length = 12): string => {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';\n  let result = '';\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return result;\n};\n\n/**\n * API service for handling deal-related data and goal tracking\n */\n\n// Define types for the goal tracking data\nexport interface Deal {\n  id: string;\n  salesperson_id: string;\n  sale_date: string;\n  front_end_gross?: number;\n  back_end_gross?: number;\n  [key: string]: any; // Allow for additional properties\n}\n\nexport interface GoalProgressMetrics {\n  expected: number;\n  actual: number;\n  progress: number;\n  status: 'on-track' | 'slightly-behind' | 'behind' | 'neutral';\n  progressRatio: number;\n}\n\nexport interface GoalTrackingData {\n  deals: Deal[];\n  daysOff: number[];\n  progressMetrics: GoalProgressMetrics;\n  daysInMonth: number;\n  currentDay: number;\n}\n\n/**\n * Gets all deals for the current user in the specified date range\n * @param userId - The ID of the current user\n * @param startDate - Start date in ISO format (YYYY-MM-DD)\n * @param endDate - End date in ISO format (YYYY-MM-DD)\n * @returns Promise with the deals data\n */\nexport const getUserDeals = async (\n  userId: string,\n  startDate: string,\n  endDate: string\n): Promise<Deal[]> => {\n  console.log('[apiService] Getting deals for user:', userId, 'from:', startDate, 'to:', endDate);\n\n  try {\n    const { data, error } = await supabase\n      .from('deals')\n      .select('*')\n      .eq('salesperson_id', userId)\n      .gte('sale_date', startDate)\n      .lte('sale_date', endDate);\n\n    if (error) {\n      console.error('[apiService] Error fetching deals:', error);\n      throw error;\n    }\n\n    console.log(`[apiService] Found ${data?.length || 0} deals`);\n    return data || [];\n  } catch (error) {\n    console.error('[apiService] Unexpected error fetching deals:', error);\n    throw error;\n  }\n};\n\n/**\n * Gets days off for a salesperson in the current month\n * @param userId - The ID of the current user\n * @param startDate - Start date in ISO format (YYYY-MM-DD)\n * @param endDate - End date in ISO format (YYYY-MM-DD)\n * @returns Promise with array of day numbers (1-31) that are days off\n */\nexport const getSalespersonDaysOff = async (\n  userId: string,\n  startDate: string,\n  endDate: string\n): Promise<number[]> => {\n  console.log('[apiService] Getting days off for user:', userId);\n\n  try {\n    // Query schedule data from Supabase\n    const { data, error } = await supabase\n      .from('schedule')\n      .select('*')\n      .eq('user_id', userId)\n      .gte('date', startDate)\n      .lte('date', endDate)\n      .eq('is_day_off', true);\n\n    if (error) {\n      console.error('[apiService] Error fetching schedule:', error);\n      // Return default days off if there's an error\n      return [5, 8, 15, 18, 25, 27, 29];\n    }\n\n    // Extract day numbers from dates\n    const daysOff =\n      data?.map(entry => {\n        const date = new Date(entry.date);\n        return date.getDate();\n      }) || [];\n\n    console.log('[apiService] Days off this month:', daysOff);\n\n    // If no days off are scheduled, return default pattern\n    if (daysOff.length === 0) {\n      console.log('[apiService] No days off found, using default pattern');\n      return [5, 8, 15, 18, 25, 27, 29];\n    }\n\n    return daysOff;\n  } catch (error) {\n    console.error('[apiService] Unexpected error fetching schedule:', error);\n    // Return default days off on error\n    return [5, 8, 15, 18, 25, 27, 29];\n  }\n};\n\n/**\n * Calculate expected sales based on the non-linear sales pace model\n * @param currentDay - The current day of the month\n * @param daysOff - Array of days that are days off\n * @returns The expected number of sales by the current day\n */\nexport const calculateExpectedSales = (currentDay: number, daysOff: number[]): number => {\n  let expectedSales = 0;\n\n  // Phase 1: Days 1-10 - 1 sale every 3 days (except days off)\n  for (let i = 1; i <= Math.min(10, currentDay); i++) {\n    if (!daysOff.includes(i) && i % 3 === 0) {\n      expectedSales++;\n    }\n  }\n\n  // Phase 2: Days 11-20 - 1 sale every 2 days (except days off)\n  if (currentDay > 10) {\n    for (let i = 11; i <= Math.min(20, currentDay); i++) {\n      if (!daysOff.includes(i) && i % 2 === 0) {\n        expectedSales++;\n      }\n    }\n  }\n\n  // Phase 3: Days 21-30/31 - 1 sale every day (except days off)\n  if (currentDay > 20) {\n    for (let i = 21; i <= currentDay; i++) {\n      if (!daysOff.includes(i)) {\n        expectedSales++;\n      }\n    }\n  }\n\n  console.log(`[apiService] Expected sales by day ${currentDay}:`, expectedSales);\n  return expectedSales;\n};\n\n/**\n * Calculate goal progress metrics\n * @param deals - Array of deal objects\n * @param currentDay - Current day of the month\n * @param daysOff - Array of days off\n * @param monthlyGoal - Monthly sales goal target\n * @returns Object with goal progress metrics\n */\nexport const calculateGoalProgress = (\n  deals: Deal[],\n  currentDay: number,\n  daysOff: number[],\n  monthlyGoal: number = 15\n): GoalProgressMetrics => {\n  // Calculate expected sales by the current day\n  const expectedSales = calculateExpectedSales(currentDay, daysOff);\n\n  // Count actual sales\n  const actualSales = deals.length;\n\n  // Calculate progress ratio\n  const progressRatio = actualSales / (expectedSales || 1); // Avoid division by zero\n\n  // Determine status based on progress ratio\n  let status: 'on-track' | 'slightly-behind' | 'behind' | 'neutral' = 'neutral';\n  if (progressRatio >= 1) {\n    status = 'on-track'; // Green\n  } else if (progressRatio >= 0.8) {\n    status = 'slightly-behind'; // Yellow\n  } else {\n    status = 'behind'; // Red\n  }\n\n  // Calculate overall progress percentage toward monthly goal\n  const progressPercentage = Math.min(100, Math.round((actualSales / monthlyGoal) * 100));\n\n  console.log('[apiService] Goal progress calculation:', {\n    currentDay,\n    expectedSales,\n    actualSales,\n    progressRatio,\n    status,\n    progressPercentage,\n  });\n\n  return {\n    expected: expectedSales,\n    actual: actualSales,\n    progress: progressPercentage,\n    status,\n    progressRatio,\n  };\n};\n\n/**\n * Get all data needed for goal tracking\n * @param userId - User ID of the salesperson\n * @returns Promise with the goal tracking data\n */\nexport const getGoalTrackingData = async (userId: string): Promise<GoalTrackingData> => {\n  // Get current month date range\n  const currentDate = new Date();\n  const currentYear = currentDate.getFullYear();\n  const currentMonth = currentDate.getMonth();\n  const currentDay = currentDate.getDate();\n\n  const startDate = new Date(currentYear, currentMonth, 1).toISOString().split('T')[0];\n  const endDate = new Date(currentYear, currentMonth + 1, 0).toISOString().split('T')[0];\n\n  try {\n    // Get deals and days off in parallel\n    const [deals, daysOff] = await Promise.all([\n      getUserDeals(userId, startDate, endDate),\n      getSalespersonDaysOff(userId, startDate, endDate),\n    ]);\n\n    // Calculate goal progress\n    const progressMetrics = calculateGoalProgress(deals, currentDay, daysOff);\n\n    return {\n      deals,\n      daysOff,\n      progressMetrics,\n      daysInMonth: new Date(currentYear, currentMonth + 1, 0).getDate(),\n      currentDay,\n    };\n  } catch (error) {\n    console.error('[apiService] Error in getGoalTrackingData:', error);\n    throw error;\n  }\n};\n\n/**\n * Sets up RLS policies to allow access across dealerships within a group\n */\nexport const setupGroupRlsPolicies = async (\n  groupId: number,\n  dealershipIds: number[]\n): Promise<{ success: boolean; message: string; error?: any }> => {\n  try {\n    console.log(\n      `[apiService] Setting up RLS policies for group ${groupId} with ${dealershipIds.length} dealerships`\n    );\n\n    // For each dealership in the group, we need to create policies:\n    // 1. For group_admin role to access all dealerships in the group\n    // 2. For area_vp role to access assigned dealerships\n\n    // First, get the role IDs\n    const { data: roles, error: rolesError } = await supabase\n      .from('roles')\n      .select('id, name')\n      .in('name', ['group_admin', 'area_vp', 'dealership_admin']);\n\n    if (rolesError) {\n      console.error('[apiService] Error fetching roles:', rolesError);\n      throw rolesError;\n    }\n\n    const groupAdminRoleId = roles.find(r => r.name === 'group_admin')?.id;\n    const areaVpRoleId = roles.find(r => r.name === 'area_vp')?.id;\n\n    if (!groupAdminRoleId || !areaVpRoleId) {\n      console.error('[apiService] Missing required role IDs');\n      throw new Error('Required role IDs not found');\n    }\n\n    console.log(\n      '[apiService] Found role IDs - Group Admin:',\n      groupAdminRoleId,\n      'Area VP:',\n      areaVpRoleId\n    );\n\n    // Create mapping records for each dealership in the group\n    const mappings = dealershipIds.map(dealershipId => ({\n      group_id: groupId,\n      dealership_id: dealershipId,\n      created_at: new Date().toISOString(),\n    }));\n\n    const { error: mappingError } = await supabase\n      .from('group_dealership_mappings')\n      .upsert(mappings);\n\n    if (mappingError) {\n      console.error('[apiService] Error creating group dealership mappings:', mappingError);\n      throw mappingError;\n    }\n\n    console.log(`[apiService] Created ${mappings.length} group dealership mappings`);\n\n    // Create an RLS policy that grants access to users with role_id = group_admin_role_id\n    // where user_metadata->group_id = the group_id of the dealership\n    for (const dealershipId of dealershipIds) {\n      // Create log entry for this setup\n      await logSchemaOperation('setup_group_rls', {\n        group_id: groupId,\n        dealership_id: dealershipId,\n        roles: {\n          group_admin: groupAdminRoleId,\n          area_vp: areaVpRoleId,\n        },\n      });\n    }\n\n    console.log('[apiService] Group RLS policies setup complete');\n\n    return {\n      success: true,\n      message: `RLS policies configured for group ${groupId}`,\n    };\n  } catch (error) {\n    console.error('[apiService] Error setting up group RLS policies:', error);\n    return {\n      success: false,\n      message: 'Failed to set up group RLS policies',\n      error,\n    };\n  }\n};\n\n/**\n * Creates a schema for a Finance Manager in Supabase\n */\nexport const createFinanceManagerSchema = async (\n  schemaName: string\n): Promise<{ success: boolean; message: string; error?: any }> => {\n  try {\n    console.log(`[apiService] Creating finance manager schema: ${schemaName}`);\n\n    // Get current user for logging\n    const user = await getCurrentUser();\n\n    // Execute SQL to create schema\n    const { error: schemaError } = await supabase.rpc('create_schema', {\n      schema_name: schemaName,\n    });\n\n    if (schemaError) {\n      console.error(`[apiService] Error creating schema ${schemaName}:`, schemaError);\n      throw schemaError;\n    }\n\n    console.log(`[apiService] Schema ${schemaName} created successfully. Creating tables...`);\n\n    // Create deals table in the schema\n    const createDealsTableQuery = `\n      CREATE TABLE IF NOT EXISTS \"${schemaName}\".deals (\n        id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n        user_id UUID NOT NULL REFERENCES auth.users(id),\n        deal_number TEXT,\n        stock_number TEXT,\n        vin TEXT,\n        customer_name TEXT,\n        vehicle TEXT,\n        sale_date DATE NOT NULL DEFAULT CURRENT_DATE,\n        amount NUMERIC(10,2),\n        products JSONB DEFAULT '[]',\n        profit NUMERIC(10,2) DEFAULT 0,\n        status TEXT DEFAULT 'pending',\n        deal_details JSONB,\n        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n      );\n    `;\n\n    const { error: tableError } = await supabase.rpc('run_sql', {\n      sql_query: createDealsTableQuery,\n    });\n\n    if (tableError) {\n      console.error(`[apiService] Error creating deals table in ${schemaName}:`, tableError);\n      throw tableError;\n    }\n\n    // Set RLS policies for the deals table\n    const createRlsPolicyQuery = `\n      -- Enable RLS on the deals table\n      ALTER TABLE \"${schemaName}\".deals ENABLE ROW LEVEL SECURITY;\n      \n      -- Create policy for users to select their own deals\n      CREATE POLICY \"Users can view their own deals\" \n      ON \"${schemaName}\".deals FOR SELECT \n      USING (auth.uid() = user_id);\n      \n      -- Create policy for users to insert their own deals\n      CREATE POLICY \"Users can insert their own deals\" \n      ON \"${schemaName}\".deals FOR INSERT \n      WITH CHECK (auth.uid() = user_id);\n      \n      -- Create policy for users to update their own deals\n      CREATE POLICY \"Users can update their own deals\" \n      ON \"${schemaName}\".deals FOR UPDATE\n      USING (auth.uid() = user_id);\n    `;\n\n    const { error: rlsError } = await supabase.rpc('run_sql', {\n      sql_query: createRlsPolicyQuery,\n    });\n\n    if (rlsError) {\n      console.error(`[apiService] Error setting RLS policies in ${schemaName}:`, rlsError);\n      throw rlsError;\n    }\n\n    // Log the schema operation\n    await logSchemaOperation('create_finance_manager_schema', {\n      schemaName,\n      createdBy: user?.id,\n      timestamp: new Date().toISOString(),\n    });\n\n    console.log(`[apiService] Finance manager schema ${schemaName} setup completed successfully`);\n\n    return {\n      success: true,\n      message: `Finance manager schema ${schemaName} created successfully`,\n    };\n  } catch (error) {\n    console.error(`[apiService] Error in createFinanceManagerSchema:`, error);\n    return {\n      success: false,\n      message: `Failed to create finance manager schema: ${error.message || error}`,\n      error,\n    };\n  }\n};\n\n/**\n * Logs a deal for a Finance Manager in their schema's deals table\n */\nexport const logFinanceManagerDeal = async (\n  schema: string,\n  dealData: {\n    deal_number?: string;\n    stock_number?: string;\n    vin?: string;\n    customer_name: string;\n    vehicle: string;\n    sale_date?: string;\n    amount?: number;\n    products?: string[];\n    profit?: number;\n    status?: string;\n    deal_details?: any;\n  }\n): Promise<{ success: boolean; deal?: any; message: string; error?: any }> => {\n  try {\n    console.log(`[apiService] Logging finance manager deal to schema: ${schema}`);\n    const user = await getCurrentUser();\n\n    if (!user) {\n      throw new Error('Not authenticated');\n    }\n\n    // Format the deal data\n    const formattedDeal = {\n      user_id: user.id,\n      deal_number: dealData.deal_number || `D${Math.floor(1000 + Math.random() * 9000)}`,\n      stock_number: dealData.stock_number || '',\n      vin: dealData.vin || '',\n      customer_name: dealData.customer_name,\n      vehicle: dealData.vehicle,\n      sale_date: dealData.sale_date || new Date().toISOString().split('T')[0],\n      amount: dealData.amount || 0,\n      products: dealData.products ? JSON.stringify(dealData.products) : '[]',\n      profit: dealData.profit || 0,\n      status: dealData.status || 'pending',\n      deal_details: dealData.deal_details ? JSON.stringify(dealData.deal_details) : '{}',\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString(),\n    };\n\n    // Construct SQL query to insert into the specific schema\n    const insertQuery = `\n      INSERT INTO \"${schema}\".deals (\n        user_id, deal_number, stock_number, vin, customer_name, \n        vehicle, sale_date, amount, products, profit, \n        status, deal_details, created_at, updated_at\n      ) \n      VALUES (\n        '${formattedDeal.user_id}', \n        '${formattedDeal.deal_number}', \n        '${formattedDeal.stock_number}', \n        '${formattedDeal.vin}', \n        '${formattedDeal.customer_name}', \n        '${formattedDeal.vehicle}', \n        '${formattedDeal.sale_date}', \n        ${formattedDeal.amount}, \n        '${formattedDeal.products}', \n        ${formattedDeal.profit}, \n        '${formattedDeal.status}', \n        '${formattedDeal.deal_details}',\n        '${formattedDeal.created_at}',\n        '${formattedDeal.updated_at}'\n      )\n      RETURNING *;\n    `;\n\n    // Execute the query\n    const { data, error } = await supabase.rpc('run_sql', {\n      sql_query: insertQuery,\n    });\n\n    if (error) {\n      console.error(`[apiService] Error inserting deal into ${schema}:`, error);\n      throw error;\n    }\n\n    console.log(`[apiService] Deal logged successfully to ${schema}:`, data);\n\n    return {\n      success: true,\n      deal: data && data.length > 0 ? data[0] : null,\n      message: 'Deal logged successfully',\n    };\n  } catch (error) {\n    console.error(`[apiService] Error in logFinanceManagerDeal:`, error);\n    return {\n      success: false,\n      message: `Failed to log deal: ${error.message || error}`,\n      error,\n    };\n  }\n};\n\n/**\n * Gets deals for a Finance Manager from their schema\n */\nexport const getFinanceManagerDeals = async (\n  schema: string,\n  options?: {\n    limit?: number;\n    offset?: number;\n    sortBy?: string;\n    sortDirection?: 'asc' | 'desc';\n    filter?: Record<string, any>;\n  }\n): Promise<{ success: boolean; deals: any[]; count: number; message: string; error?: any }> => {\n  try {\n    console.log(`[apiService] Getting finance manager deals from schema: ${schema}`);\n    const user = await getCurrentUser();\n\n    if (!user) {\n      throw new Error('Not authenticated');\n    }\n\n    const limit = options?.limit || 50;\n    const offset = options?.offset || 0;\n    const sortBy = options?.sortBy || 'created_at';\n    const sortDirection = options?.sortDirection || 'desc';\n\n    // Build the filter conditions if provided\n    let filterCondition = '';\n    if (options?.filter) {\n      const conditions = [];\n      Object.entries(options.filter).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          // Handle string values\n          if (typeof value === 'string') {\n            conditions.push(`${key} ILIKE '%${value}%'`);\n          }\n          // Handle numeric values\n          else if (typeof value === 'number') {\n            conditions.push(`${key} = ${value}`);\n          }\n          // Handle boolean values\n          else if (typeof value === 'boolean') {\n            conditions.push(`${key} = ${value}`);\n          }\n          // Handle date ranges\n          else if (value.start && value.end) {\n            conditions.push(`${key} BETWEEN '${value.start}' AND '${value.end}'`);\n          }\n        }\n      });\n      if (conditions.length > 0) {\n        filterCondition = `AND ${conditions.join(' AND ')}`;\n      }\n    }\n\n    // Construct SQL query to select from the specific schema\n    const selectQuery = `\n      SELECT * FROM \"${schema}\".deals \n      WHERE user_id = '${user.id}' ${filterCondition}\n      ORDER BY ${sortBy} ${sortDirection}\n      LIMIT ${limit} OFFSET ${offset};\n    `;\n\n    // Also get the total count for pagination\n    const countQuery = `\n      SELECT COUNT(*) FROM \"${schema}\".deals \n      WHERE user_id = '${user.id}' ${filterCondition};\n    `;\n\n    // Execute the query\n    const { data, error } = await supabase.rpc('run_sql', {\n      sql_query: selectQuery,\n    });\n\n    if (error) {\n      console.error(`[apiService] Error selecting deals from ${schema}:`, error);\n      throw error;\n    }\n\n    // Get the count\n    const { data: countData, error: countError } = await supabase.rpc('run_sql', {\n      sql_query: countQuery,\n    });\n\n    if (countError) {\n      console.error(`[apiService] Error counting deals in ${schema}:`, countError);\n      throw countError;\n    }\n\n    const count = countData && countData.length > 0 ? parseInt(countData[0].count) : 0;\n\n    console.log(\n      `[apiService] Retrieved ${data ? data.length : 0} deals from ${schema} (total: ${count})`\n    );\n\n    return {\n      success: true,\n      deals: data || [],\n      count,\n      message: `Retrieved ${data ? data.length : 0} deals successfully`,\n    };\n  } catch (error) {\n    console.error(`[apiService] Error in getFinanceManagerDeals:`, error);\n    return {\n      success: false,\n      deals: [],\n      count: 0,\n      message: `Failed to get deals: ${error.message || error}`,\n      error,\n    };\n  }\n};\n\n/**\n * Notifies master admin of new signup requests\n */\nexport const notifyMasterAdminOfSignup = async (\n  signupRequest: SignupRequest\n): Promise<{ success: boolean; message: string; error?: any }> => {\n  try {\n    console.log(\n      `[apiService] Notifying master admin of new signup: ${signupRequest.dealership_name}`\n    );\n\n    // Log notification attempt\n    const notificationData = {\n      type: 'signup_notification',\n      signup_id: signupRequest.id,\n      dealership_name: signupRequest.dealership_name,\n      email: signupRequest.email,\n      tier: signupRequest.tier,\n      timestamp: new Date().toISOString(),\n    };\n\n    // Create a notification record in the database\n    const { error: notificationError } = await supabase.from('admin_notifications').insert({\n      type: 'signup_request',\n      content: {\n        signup_id: signupRequest.id,\n        dealership_name: signupRequest.dealership_name,\n        contact_person: signupRequest.contact_person,\n        email: signupRequest.email,\n        tier: signupRequest.tier,\n        add_ons: signupRequest.add_ons,\n      },\n      is_read: false,\n      created_at: new Date().toISOString(),\n    });\n\n    if (notificationError) {\n      console.error('[apiService] Error creating notification record:', notificationError);\n      // Don't throw - this shouldn't block the signup process\n    }\n\n    // In a real system, we would send an email or push notification here\n    // For now, just log it\n    console.log(\n      `[apiService] Would send email to master admin about new ${signupRequest.tier} signup: ${signupRequest.dealership_name}`\n    );\n\n    return {\n      success: true,\n      message: 'Notification sent to master admin',\n    };\n  } catch (error) {\n    console.error('[apiService] Error notifying master admin:', error);\n    // Return success anyway - we don't want signup to fail if notification fails\n    return {\n      success: false,\n      message: 'Failed to send notification to master admin',\n      error,\n    };\n  }\n};\n\n/**\n * Get user limits for a dealership based on subscription tier and add-ons\n */\nexport const getDealershipUserLimits = async (\n  dealershipId: string\n): Promise<{\n  success: boolean;\n  limits?: {\n    sales_people: number;\n    finance_managers: number;\n    sales_managers: number;\n    general_managers: number;\n    finance_assistants: number;\n    others: number;\n  };\n  tier?: string;\n  add_ons?: string[];\n  error?: any;\n}> => {\n  try {\n    console.log(`[apiService] Getting user limits for dealership: ${dealershipId}`);\n\n    // Get the dealership details including its subscription tier and add-ons\n    const { data: dealership, error: dealershipError } = await supabase\n      .from('dealerships')\n      .select('*')\n      .eq('id', dealershipId)\n      .single();\n\n    if (dealershipError) {\n      console.error(`[apiService] Error getting dealership info: ${dealershipError.message}`);\n      throw dealershipError;\n    }\n\n    // Base limits for the dealership tier\n    let limits = {\n      sales_people: 10,\n      finance_managers: 3,\n      sales_managers: 3,\n      general_managers: 1,\n      finance_assistants: 2,\n      others: 2,\n    };\n\n    // Adjust limits based on add-ons\n    const addOns = dealership.add_ons || [];\n\n    if (addOns.includes('plus')) {\n      // + Version add-on increases limits by 50%\n      limits = {\n        sales_people: 15,\n        finance_managers: 5,\n        sales_managers: 5,\n        general_managers: 2,\n        finance_assistants: 3,\n        others: 3,\n      };\n    }\n\n    if (addOns.includes('plusplus')) {\n      // ++ Version add-on increases limits by 150%\n      limits = {\n        sales_people: 25,\n        finance_managers: 8,\n        sales_managers: 8,\n        general_managers: 3,\n        finance_assistants: 5,\n        others: 5,\n      };\n    }\n\n    return {\n      success: true,\n      limits,\n      tier: dealership.tier,\n      add_ons: addOns,\n    };\n  } catch (error) {\n    console.error(`[apiService] Error getting user limits: ${error}`);\n    return {\n      success: false,\n      error,\n    };\n  }\n};\n\n/**\n * Check if a dealership can add a user of a specific role\n */\nexport const canAddUserWithRole = async (\n  dealershipId: string,\n  role: string\n): Promise<{\n  success: boolean;\n  canAdd: boolean;\n  currentCount?: number;\n  limit?: number;\n  error?: any;\n}> => {\n  try {\n    console.log(\n      `[apiService] Checking if dealership ${dealershipId} can add user with role ${role}`\n    );\n\n    // Get the dealership's user limits\n    const { success, limits, error } = await getDealershipUserLimits(dealershipId);\n\n    if (!success || !limits) {\n      throw error || new Error('Failed to get user limits');\n    }\n\n    // Count existing users by role\n    const { data: users, error: usersError } = await supabase\n      .from('profiles')\n      .select('role')\n      .eq('dealership_id', dealershipId);\n\n    if (usersError) {\n      console.error(`[apiService] Error counting users: ${usersError.message}`);\n      throw usersError;\n    }\n\n    // Map the role to its category\n    let roleCategory;\n    if (role.includes('sales') && !role.includes('manager')) {\n      roleCategory = 'sales_people';\n    } else if (\n      role.includes('finance') &&\n      !role.includes('manager') &&\n      !role.includes('director')\n    ) {\n      roleCategory = 'finance_assistants';\n    } else if (\n      role.includes('finance') &&\n      (role.includes('manager') || role.includes('director'))\n    ) {\n      roleCategory = 'finance_managers';\n    } else if (role.includes('sales') && role.includes('manager')) {\n      roleCategory = 'sales_managers';\n    } else if (role.includes('general') && role.includes('manager')) {\n      roleCategory = 'general_managers';\n    } else {\n      roleCategory = 'others';\n    }\n\n    // Count users in this category\n    const count = users.filter(user => {\n      if (roleCategory === 'sales_people') {\n        return user.role.includes('sales') && !user.role.includes('manager');\n      } else if (roleCategory === 'finance_assistants') {\n        return (\n          user.role.includes('finance') &&\n          !user.role.includes('manager') &&\n          !user.role.includes('director')\n        );\n      } else if (roleCategory === 'finance_managers') {\n        return (\n          user.role.includes('finance') &&\n          (user.role.includes('manager') || user.role.includes('director'))\n        );\n      } else if (roleCategory === 'sales_managers') {\n        return user.role.includes('sales') && user.role.includes('manager');\n      } else if (roleCategory === 'general_managers') {\n        return user.role.includes('general') && user.role.includes('manager');\n      } else {\n        return ![\n          'sales_people',\n          'finance_managers',\n          'sales_managers',\n          'general_managers',\n          'finance_assistants',\n        ].includes(getCategory(user.role));\n      }\n    }).length;\n\n    // Check if under limit\n    const limit = limits[roleCategory];\n    const canAdd = count < limit;\n\n    return {\n      success: true,\n      canAdd,\n      currentCount: count,\n      limit,\n    };\n  } catch (error) {\n    console.error(`[apiService] Error checking if can add user: ${error}`);\n    return {\n      success: false,\n      canAdd: false,\n      error,\n    };\n  }\n};\n\n// Helper function to get role category\nfunction getCategory(role: string): string {\n  if (role.includes('sales') && !role.includes('manager')) {\n    return 'sales_people';\n  } else if (role.includes('finance') && !role.includes('manager') && !role.includes('director')) {\n    return 'finance_assistants';\n  } else if (role.includes('finance') && (role.includes('manager') || role.includes('director'))) {\n    return 'finance_managers';\n  } else if (role.includes('sales') && role.includes('manager')) {\n    return 'sales_managers';\n  } else if (role.includes('general') && role.includes('manager')) {\n    return 'general_managers';\n  } else {\n    return 'others';\n  }\n}\n\n/**\n * Helper functions for signup approval\n */\n\n// Helper function to generate a password\nexport function generatePassword() {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';\n  let password = '';\n  for (let i = 0; i < 12; i++) {\n    password += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return password;\n}\n\n// Handle dealer group signups\nasync function handleDealerGroupSignup(\n  request: any,\n  options: any\n): Promise<{\n  success: boolean;\n  message: string;\n  error?: any;\n  groupId?: number;\n  dealershipIds?: number[];\n}> {\n  try {\n    console.log(`[apiService] Processing dealer group signup for ${request.dealership_name}`);\n\n    // Get current user for logging\n    const user = await getCurrentUser();\n    if (!user) {\n      throw new Error('Not authenticated');\n    }\n\n    // Get group level and dealership count\n    const groupLevel = options.groupLevel || request.group_level || 'level_1';\n    const dealershipCount = options.dealershipCount || request.dealership_count || 2;\n    const addOns = options.addOns || request.add_ons || [];\n\n    console.log(\n      `[apiService] Group level: ${groupLevel}, Dealership count: ${dealershipCount}, Add-ons: ${JSON.stringify(\n        addOns\n      )}`\n    );\n\n    // Generate base schema name\n    const baseSchemaName =\n      options.schemaName ||\n      `group_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 7)}`;\n\n    // Set user limits based on add-ons\n    const userLimits = {\n      sales_people: 10,\n      finance_managers: 3,\n      sales_managers: 3,\n      general_managers: 1,\n      finance_assistants: 2,\n      others: 2,\n      area_vps: 0, // Default is 0\n    };\n\n    // Apply + Version add-on limits\n    if (addOns.includes('plus')) {\n      userLimits.sales_people = 15;\n      userLimits.finance_managers = 5;\n      userLimits.sales_managers = 5;\n      userLimits.general_managers = 2;\n      userLimits.finance_assistants = 3;\n      userLimits.others = 3;\n\n      // Add Area VPs based on tier\n      userLimits.area_vps = groupLevel === 'level_1' ? 1 : 2;\n    }\n\n    // Apply ++ Version add-on limits\n    if (addOns.includes('plusplus')) {\n      userLimits.sales_people = 25;\n      userLimits.finance_managers = 8;\n      userLimits.sales_managers = 8;\n      userLimits.general_managers = 3;\n      userLimits.finance_assistants = 5;\n      userLimits.others = 5;\n\n      // Unlimited AVPs for ++ Version\n      userLimits.area_vps = 999; // Effectively unlimited\n    }\n\n    // Get pricing based on tier level\n    const pricingPerDealership =\n      groupLevel === 'level_1' ? 200 : groupLevel === 'level_2' ? 250 : 300; // Level 3 or default\n\n    // Create the dealer group\n    const { data: groupData, error: groupError } = await supabase\n      .from('dealership_groups')\n      .insert({\n        name: request.dealership_name,\n        settings: {\n          level: groupLevel,\n          dealership_count: dealershipCount,\n          add_ons: addOns,\n          user_limits: userLimits,\n          pricing_per_dealership: pricingPerDealership,\n          stripe_subscription_id: request.stripe_session_id,\n        },\n        status: 'active',\n        created_by: user.id,\n      })\n      .select()\n      .single();\n\n    if (groupError) {\n      console.error(`[apiService] Error creating dealership group: ${groupError.message}`);\n      throw groupError;\n    }\n\n    const groupId = groupData.id;\n    console.log(`[apiService] Created dealer group: ${groupData.name}, ID: ${groupId}`);\n\n    // Create dealerships under the group\n    const dealershipIds: number[] = [];\n\n    for (let i = 0; i < dealershipCount; i++) {\n      // Create schema name for this dealership\n      const schemaName = `${baseSchemaName}_${i + 1}`;\n      const dealershipName = `${request.dealership_name} - Location ${i + 1}`;\n\n      // Create schema\n      if (options.createSchema) {\n        console.log(`[apiService] Creating schema for dealership ${i + 1}: ${schemaName}`);\n        const schemaResult = await createDealershipSchema(schemaName);\n\n        if (!schemaResult.success) {\n          console.error(\n            `[apiService] Error creating schema for dealership ${i + 1}:`,\n            schemaResult.error\n          );\n          // Continue anyway - we'll just log the error\n        }\n      }\n\n      // Create dealership record\n      const { data: dealershipData, error: dealershipError } = await supabase\n        .from('dealerships')\n        .insert({\n          name: dealershipName,\n          group_id: groupId,\n          schema_name: schemaName,\n          tier: 'dealership',\n          add_ons: addOns,\n          status: 'active',\n          contact_email: request.email,\n          contact_name: request.contact_person,\n          contact_phone: request.phone,\n          subscription_status: 'active',\n          created_by: user.id,\n          settings: {\n            user_limits: userLimits,\n            group_level: groupLevel,\n            dealership_index: i + 1,\n          },\n        })\n        .select()\n        .single();\n\n      if (dealershipError) {\n        console.error(`[apiService] Error creating dealership ${i + 1}:`, dealershipError);\n        continue; // Skip to next dealership on error\n      }\n\n      dealershipIds.push(dealershipData.id);\n      console.log(\n        `[apiService] Created dealership: ${dealershipData.name}, ID: ${dealershipData.id}`\n      );\n    }\n\n    // Create admin user if requested\n    if (options.adminEmail) {\n      console.log(`[apiService] Creating group admin user: ${options.adminEmail}`);\n\n      // Get primary dealership id for the admin\n      const primaryDealershipId = dealershipIds[0];\n\n      // Check if user already exists\n      const { data: existingUser, error: existingUserError } = await supabase\n        .from('profiles')\n        .select('id')\n        .eq('email', options.adminEmail)\n        .single();\n\n      if (existingUserError && existingUserError.code !== 'PGRST116') {\n        console.error(\n          `[apiService] Error checking for existing user: ${existingUserError.message}`\n        );\n        throw existingUserError;\n      }\n\n      if (existingUser) {\n        console.log(`[apiService] User already exists: ${options.adminEmail}`);\n\n        // Update existing user to add group admin role\n        const { error: updateUserError } = await supabase\n          .from('profiles')\n          .update({\n            dealership_id: primaryDealershipId,\n            group_id: groupId,\n            role: 'dealer_group_admin',\n            is_group_admin: true,\n          })\n          .eq('email', options.adminEmail);\n\n        if (updateUserError) {\n          console.error(`[apiService] Error updating user: ${updateUserError.message}`);\n          throw updateUserError;\n        }\n      } else {\n        // Create new user\n        const { error: signupError, data: signupData } = await supabase.auth.signUp({\n          email: options.adminEmail,\n          password: options.tempPassword || generatePassword(),\n        });\n\n        if (signupError) {\n          console.error(`[apiService] Error creating user: ${signupError.message}`);\n          throw signupError;\n        }\n\n        // Create profile record\n        const { error: profileError } = await supabase.from('profiles').insert({\n          id: signupData?.user?.id,\n          email: options.adminEmail,\n          dealership_id: primaryDealershipId,\n          group_id: groupId,\n          role: 'dealer_group_admin',\n          is_group_admin: true,\n          first_name: options.adminName?.split(' ')[0] || '',\n          last_name: options.adminName?.split(' ').slice(1).join(' ') || '',\n        });\n\n        if (profileError) {\n          console.error(`[apiService] Error creating profile: ${profileError.message}`);\n          throw profileError;\n        }\n      }\n    }\n\n    // Set up cross-dealership RLS policies for the group\n    await setupGroupRlsPolicies(groupId, dealershipIds);\n\n    // Create a subscription event record\n    const totalAmount =\n      pricingPerDealership * dealershipCount +\n      (addOns.includes('plus') ? 100 : 0) +\n      (addOns.includes('plusplus') ? 500 : 0);\n\n    await recordSubscriptionEvent({\n      group_id: groupId,\n      dealership_id: dealershipIds[0],\n      event_type: 'signup',\n      tier: 'dealer_group',\n      add_ons: addOns,\n      amount: totalAmount,\n      user_id: user.id,\n    });\n\n    console.log(\n      `[apiService] Group signup completed successfully. Created ${dealershipIds.length} dealerships.`\n    );\n\n    return {\n      success: true,\n      message: `Dealer Group created with ${dealershipIds.length} dealerships`,\n      groupId,\n      dealershipIds,\n    };\n  } catch (error) {\n    console.error('[apiService] Error in handleDealerGroupSignup:', error);\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : 'An unknown error occurred',\n      error,\n    };\n  }\n}\n\n// Handle finance manager signups\nasync function handleFinanceManagerSignup(\n  request: any,\n  options: any\n): Promise<{\n  success: boolean;\n  message: string;\n  error?: any;\n}> {\n  try {\n    console.log(`[apiService] Processing finance manager signup for ${request.contact_person}`);\n    console.log(`[apiService] Promotional pricing applied: Free (normally $5/month)`);\n\n    // Get current user for logging\n    const user = await getCurrentUser();\n    if (!user) {\n      throw new Error('Not authenticated');\n    }\n\n    // Generate schema name if not provided\n    const schemaName =\n      options.schemaName ||\n      `finance_mgr_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 7)}`;\n\n    // Create schema for the finance manager\n    if (options.createSchema !== false) {\n      console.log(`[apiService] Creating schema for finance manager: ${schemaName}`);\n      const schemaResult = await createFinanceManagerSchema(schemaName);\n\n      if (!schemaResult.success) {\n        console.error('[apiService] Error creating finance manager schema:', schemaResult.error);\n        throw new Error(`Failed to create schema: ${schemaResult.message}`);\n      }\n    }\n\n    // Create admin user if requested\n    if (options.adminEmail) {\n      console.log(`[apiService] Creating finance manager user: ${options.adminEmail}`);\n\n      // Check if user already exists\n      const { data: existingUser, error: existingUserError } = await supabase\n        .from('profiles')\n        .select('id')\n        .eq('email', options.adminEmail)\n        .single();\n\n      if (existingUserError && existingUserError.code !== 'PGRST116') {\n        console.error(\n          `[apiService] Error checking for existing user: ${existingUserError.message}`\n        );\n        throw existingUserError;\n      }\n\n      if (existingUser) {\n        console.log(`[apiService] User already exists: ${options.adminEmail}`);\n\n        // Update existing user to add finance manager role and schema\n        const { error: updateUserError } = await supabase\n          .from('profiles')\n          .update({\n            role: 'finance_manager',\n            schema_name: schemaName,\n          })\n          .eq('email', options.adminEmail);\n\n        if (updateUserError) {\n          console.error(`[apiService] Error updating user: ${updateUserError.message}`);\n          throw updateUserError;\n        }\n      } else {\n        // Create new user\n        const { error: signupError, data: signupData } = await supabase.auth.signUp({\n          email: options.adminEmail,\n          password: options.tempPassword || generatePassword(),\n          options: {\n            data: {\n              role: 'finance_manager',\n              schema_name: schemaName,\n            },\n          },\n        });\n\n        if (signupError) {\n          console.error(`[apiService] Error creating user: ${signupError.message}`);\n          throw signupError;\n        }\n\n        // Create profile record\n        const { error: profileError } = await supabase.from('profiles').insert({\n          id: signupData?.user?.id,\n          email: options.adminEmail,\n          role: 'finance_manager',\n          schema_name: schemaName,\n          first_name: options.adminName?.split(' ')[0] || '',\n          last_name: options.adminName?.split(' ').slice(1).join(' ') || '',\n          settings: {\n            subscription_tier: 'finance_manager_only',\n            trial_ends_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days trial\n            promo_applied: true, // Indicate promotion was applied\n            promo_details: 'Free instead of $5/month for a limited time',\n          },\n        });\n\n        if (profileError) {\n          console.error(`[apiService] Error creating profile: ${profileError.message}`);\n          throw profileError;\n        }\n      }\n    }\n\n    // Record subscription event with promotional pricing\n    await recordSubscriptionEvent({\n      schema_name: schemaName,\n      event_type: 'signup',\n      tier: 'finance_manager_only',\n      amount: 0, // $0/month with promotion (normally $5)\n      is_promo: true,\n      original_amount: 5,\n      user_id: user.id,\n    });\n\n    // Record the promotional signup in the promotions_usage table if it exists\n    try {\n      const { error: usageError } = await supabase.from('promotions_usage').insert({\n        promotion_tier: 'finance_manager_only',\n        user_id: options.adminEmail ? await getUserIdByEmail(options.adminEmail) : null,\n        schema_name: schemaName,\n        signup_date: new Date().toISOString(),\n      });\n\n      if (usageError) {\n        // Log but don't throw - this is supplementary tracking\n        console.log('[apiService] Note: Could not record promotion usage:', usageError.message);\n      }\n    } catch (trackingError) {\n      // Ignore errors in promotional tracking - it shouldn't block the main flow\n      console.log('[apiService] Note: Error in promotion tracking:', trackingError);\n    }\n\n    console.log(\n      `[apiService] Finance manager signup completed successfully for schema: ${schemaName} with promotional pricing`\n    );\n\n    return {\n      success: true,\n      message: `Finance Manager account created successfully with promotional pricing (Free)`,\n    };\n  } catch (error) {\n    console.error('[apiService] Error in handleFinanceManagerSignup:', error);\n    return {\n      success: false,\n      message: error instanceof Error ? error.message : 'An unknown error occurred',\n      error,\n    };\n  }\n}\n\n// Function to record subscription events\nexport const recordSubscriptionEvent = async (data: {\n  dealership_id?: number;\n  group_id?: number;\n  schema_name?: string;\n  event_type: string;\n  tier: string;\n  add_ons?: string[];\n  amount?: number;\n  is_promo?: boolean;\n  original_amount?: number;\n  user_id: string;\n}): Promise<{ success: boolean; message: string; error?: any }> => {\n  try {\n    console.log(\n      `[apiService] Recording subscription event: ${data.event_type} for tier: ${data.tier}`\n    );\n\n    if (data.is_promo) {\n      console.log(\n        `[apiService] Promotional pricing applied: ${data.amount} (original: ${data.original_amount})`\n      );\n    }\n\n    const { error } = await supabase.from('subscription_events').insert({\n      dealership_id: data.dealership_id,\n      group_id: data.group_id,\n      schema_name: data.schema_name,\n      event_type: data.event_type,\n      tier: data.tier,\n      add_ons: data.add_ons || [],\n      amount: data.amount || null,\n      is_promotional: data.is_promo || false,\n      original_amount: data.original_amount,\n      user_id: data.user_id,\n      created_at: new Date().toISOString(),\n    });\n\n    if (error) {\n      console.error('[apiService] Error recording subscription event:', error);\n      throw error;\n    }\n\n    return {\n      success: true,\n      message: 'Subscription event recorded successfully',\n    };\n  } catch (error) {\n    console.error('[apiService] Error recording subscription event:', error);\n    return {\n      success: false,\n      message: 'Failed to record subscription event',\n      error,\n    };\n  }\n};\n\n// Helper function to get user ID by email\nasync function getUserIdByEmail(email: string): Promise<string | null> {\n  try {\n    const { data, error } = await supabase\n      .from('profiles')\n      .select('id')\n      .eq('email', email)\n      .single();\n\n    if (error) {\n      console.error('[apiService] Error getting user ID by email:', error);\n      return null;\n    }\n\n    return data?.id || null;\n  } catch (error) {\n    console.error('[apiService] Exception in getUserIdByEmail:', error);\n    return null;\n  }\n}\n"],"names":["supabaseUrl","supabaseAnonKey","supabaseInstance","createSupabaseClient","createClient","supabase","userRoleCache","pendingRequests","getCurrentUser","user","userError","cachedRole","requestKey","profile","profileError","userData","userDataError","roleData","error","isTestEmail","email","loginTestUser","password","isGroupAdminEmail","signInData","signInError","userUpdateData","userUpdateError","err","data","signOut","logSchemaOperation","action","details","getUserDeals","userId","startDate","endDate","getSalespersonDaysOff","daysOff","entry","calculateExpectedSales","currentDay","expectedSales","i","calculateGoalProgress","deals","monthlyGoal","actualSales","progressRatio","status","progressPercentage","getGoalTrackingData","currentDate","currentYear","currentMonth","progressMetrics","logFinanceManagerDeal","schema","dealData","formattedDeal","insertQuery","getFinanceManagerDeals","options","limit","offset","sortBy","sortDirection","filterCondition","conditions","key","value","selectQuery","countQuery","countData","countError","count"],"mappings":"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"}